import{_ as s,c as n,o as a,a3 as p}from"./chunks/framework.CVXq2y2U.js";const b=JSON.parse('{"title":"Redis 命令集合","description":"","frontmatter":{},"headers":[],"relativePath":"column/LargeFrontEnd2023/103_Redis.md","filePath":"column/LargeFrontEnd2023/103_Redis.md"}'),e={name:"column/LargeFrontEnd2023/103_Redis.md"},l=p(`<h1 id="redis-命令集合" tabindex="-1">Redis <a href="http://doc.redisfans.com/" target="_blank">命令</a>集合 <a class="header-anchor" href="#redis-命令集合" aria-label="Permalink to &quot;Redis &lt;a href=&quot;http://doc.redisfans.com/&quot; target=&quot;_blank&quot;&gt;命令&lt;/a&gt;集合&quot;">​</a></h1><h2 id="key-键" tabindex="-1">Key（键） <a class="header-anchor" href="#key-键" aria-label="Permalink to &quot;Key（键）&quot;">​</a></h2><h3 id="del" tabindex="-1">DEL <a class="header-anchor" href="#del" aria-label="Permalink to &quot;DEL&quot;">​</a></h3><p>删除给定的一个或多个 key 。</p><p>不存在的 key 会被忽略。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DEL key [key ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#  删除单个 key</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET name huangz</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DEL name</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 删除一个不存在的 key</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS phone</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DEL phone # 失败，没有 key 被删除</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 同时删除多个 key</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET name &quot;redis&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET type &quot;key-value store&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET website &quot;redis.com&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DEL name type website</span></span>
<span class="line"><span>(integer) 3</span></span></code></pre></div><h3 id="dump" tabindex="-1">DUMP <a class="header-anchor" href="#dump" aria-label="Permalink to &quot;DUMP&quot;">​</a></h3><p>序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为 Redis 键。</p><p>序列化生成的值有以下几个特点：</p><p>序列化的值不包括任何生存时间信息。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DUMP key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SET greeting &quot;hello, dumping world!&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DUMP greeting</span></span>
<span class="line"><span>&quot;\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DUMP not-exists-key</span></span>
<span class="line"><span>(nil)</span></span></code></pre></div><h3 id="exists" tabindex="-1">EXISTS <a class="header-anchor" href="#exists" aria-label="Permalink to &quot;EXISTS&quot;">​</a></h3><p>检查给定 key 是否存在。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXISTS key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SET db &quot;redis&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS db</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DEL db</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS db</span></span>
<span class="line"><span>(integer) 0</span></span></code></pre></div><h3 id="expire" tabindex="-1">EXPIRE <a class="header-anchor" href="#expire" aria-label="Permalink to &quot;EXPIRE&quot;">​</a></h3><p>为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。</p><p>在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。</p><p>生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写(overwrite)，这意味着，如果一个命令只是修改(alter)一个带生存时间的 key 的值而不是用一个新的 key 值来代替(replace)它的话，那么生存时间不会被改变。</p><p>比如说，对一个 key 执行 INCR 命令，对一个列表进行 LPUSH 命令，或者对一个哈希表执行 HSET 命令，这类操作都不会修改 key 本身的生存时间。</p><p>另一方面，如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样。</p><p>RENAME 命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。</p><p>使用 PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个『持久的』(persistent) key 。</p><p>更新生存时间</p><p>可以对一个已经带有生存时间的 key 执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间。</p><p>过期时间的精确度</p><p>在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 key 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。</p><p>Redis 2.1.3 之前的不同之处</p><p>在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 key 会导致整个 key 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。</p><p>假设你有一项 web 服务，打算根据用户最近访问的 N 个页面来进行物品推荐，并且假设用户停止阅览超过 60 秒，那么就清空阅览记录(为了减少物品推荐的计算量，并且保持推荐物品的新鲜度)。</p><p>这些最近访问的页面记录，我们称之为『导航会话』(Navigation session)，可以用 INCR 和 RPUSH 命令在 Redis 中实现它：每当用户阅览一个网页的时候，执行以下代码：</p><p>如果用户停止阅览超过 60 秒，那么它的导航会话就会被清空，当用户重新开始阅览的时候，系统又会重新记录导航会话，继续进行物品推荐。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXPIRE key seconds</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SET cache_page &quot;www.google.com&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXPIRE cache_page 30  # 设置过期时间为 30 秒</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; TTL cache_page    # 查看剩余生存时间</span></span>
<span class="line"><span>(integer) 23</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXPIRE cache_page 30000   # 更新过期时间</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; TTL cache_page</span></span>
<span class="line"><span>(integer) 29996</span></span></code></pre></div><h3 id="expireat" tabindex="-1">EXPIREAT <a class="header-anchor" href="#expireat" aria-label="Permalink to &quot;EXPIREAT&quot;">​</a></h3><p>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。</p><p>不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXPIREAT key timestamp</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SET cache www.google.com</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXPIREAT cache 1355292000     # 这个 key 将在 2012.12.12 过期</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; TTL cache</span></span>
<span class="line"><span>(integer) 45081860</span></span></code></pre></div><h3 id="keys" tabindex="-1">KEYS <a class="header-anchor" href="#keys" aria-label="Permalink to &quot;KEYS&quot;">​</a></h3><p>查找所有符合给定模式 pattern 的 key 。</p><p>特殊符号用 \\ 隔开</p><p>Warning</p><p>KEYS 的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 key ，你最好还是用 Redis 的集合结构(set)来代替。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>KEYS pattern</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; MSET one 1 two 2 three 3 four 4  # 一次设置 4 个 key</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; KEYS *o*</span></span>
<span class="line"><span>1) &quot;four&quot;</span></span>
<span class="line"><span>2) &quot;two&quot;</span></span>
<span class="line"><span>3) &quot;one&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; KEYS t??</span></span>
<span class="line"><span>1) &quot;two&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; KEYS t[w]*</span></span>
<span class="line"><span>1) &quot;two&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; KEYS *  # 匹配数据库内所有 key</span></span>
<span class="line"><span>1) &quot;four&quot;</span></span>
<span class="line"><span>2) &quot;three&quot;</span></span>
<span class="line"><span>3) &quot;two&quot;</span></span>
<span class="line"><span>4) &quot;one&quot;</span></span></code></pre></div><h3 id="migrate" tabindex="-1">MIGRATE <a class="header-anchor" href="#migrate" aria-label="Permalink to &quot;MIGRATE&quot;">​</a></h3><p>将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。</p><p>这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。</p><p>命令的内部实现是这样的：它在当前实例对给定 key 执行 DUMP 命令 ，将它序列化，然后传送到目标实例，目标实例再使用 RESTORE 对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到 RESTORE 命令返回 OK ，它就会调用 DEL 删除自己数据库上的 key 。</p><p>timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。</p><p>MIGRATE 命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： IOERR 。</p><p>当 IOERR 出现时，有以下两种可能：</p><p>唯一不可能发生的情况就是丢失 key ，因此，如果一个客户端执行 MIGRATE 命令，并且不幸遇上 IOERR 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。</p><p>如果有其他错误发生，那么 MIGRATE 保证 key 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 key 同名的键，不过这和 MIGRATE 命令没有关系）。</p><p>可选项：</p><p>先启动两个 Redis 实例，一个使用默认的 6379 端口，一个使用 7777 端口。</p><p>然后用客户端连上 6379 端口的实例，设置一个键，然后将它迁移到 7777 端口的实例上：</p><p>使用另一个客户端，查看 7777 端口上的实例：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MIGRATE host port key destination-db timeout [COPY] [REPLACE]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ ./redis-server &amp;</span></span>
<span class="line"><span>[1] 3557</span></span>
<span class="line"><span></span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$ ./redis-server --port 7777 &amp;</span></span>
<span class="line"><span>[2] 3560</span></span>
<span class="line"><span></span></span>
<span class="line"><span>...</span></span></code></pre></div><h3 id="move" tabindex="-1">MOVE <a class="header-anchor" href="#move" aria-label="Permalink to &quot;MOVE&quot;">​</a></h3><p>将当前数据库的 key 移动到给定的数据库 db 当中。</p><p>如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。</p><p>因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOVE key db</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># key 存在于当前数据库</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SELECT 0                             # redis默认使用数据库 0，为了清晰起见，这里再显式指定一次。</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET song &quot;secret base - Zone&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; MOVE song 1                          # 将 song 移动到数据库 1</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS song                          # song 已经被移走</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SELECT 1                             # 使用数据库 1</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis:1&gt; EXISTS song                        # 证实 song 被移到了数据库 1 (注意命令提示符变成了&quot;redis:1&quot;，表明正在使用数据库 1)</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 当 key 不存在的时候</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis:1&gt; EXISTS fake_key</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis:1&gt; MOVE fake_key 0                    # 试图从数据库 1 移动一个不存在的 key 到数据库 0，失败</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis:1&gt; select 0                           # 使用数据库0</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS fake_key                      # 证实 fake_key 不存在</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 当源数据库和目标数据库有相同的 key 时</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SELECT 0                             # 使用数据库0</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span>redis&gt; SET favorite_fruit &quot;banana&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SELECT 1                             # 使用数据库1</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span>redis:1&gt; SET favorite_fruit &quot;apple&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis:1&gt; SELECT 0                           # 使用数据库0，并试图将 favorite_fruit 移动到数据库 1</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; MOVE favorite_fruit 1                # 因为两个数据库有相同的 key，MOVE 失败</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET favorite_fruit                   # 数据库 0 的 favorite_fruit 没变</span></span>
<span class="line"><span>&quot;banana&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SELECT 1</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis:1&gt; GET favorite_fruit                 # 数据库 1 的 favorite_fruit 也是</span></span>
<span class="line"><span>&quot;apple&quot;</span></span></code></pre></div><h3 id="object" tabindex="-1">OBJECT <a class="header-anchor" href="#object" aria-label="Permalink to &quot;OBJECT&quot;">​</a></h3><p>OBJECT 命令允许从内部察看给定 key 的 Redis 对象。</p><p>OBJECT 命令有多个子命令：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>OBJECT subcommand [arguments [arguments]]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SET game &quot;COD&quot;           # 设置一个字符串</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; OBJECT REFCOUNT game     # 只有一个引用</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; OBJECT IDLETIME game     # 等待一阵。。。然后查看空转时间</span></span>
<span class="line"><span>(integer) 90</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET game                 # 提取game， 让它处于活跃(active)状态</span></span>
<span class="line"><span>&quot;COD&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; OBJECT IDLETIME game     # 不再处于空转</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; OBJECT ENCODING game     # 字符串的编码方式</span></span>
<span class="line"><span>&quot;raw&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET phone 15820123123    # 大的数字也被编码为字符串</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; OBJECT ENCODING phone</span></span>
<span class="line"><span>&quot;raw&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET age 20               # 短数字被编码为 int</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; OBJECT ENCODING age</span></span>
<span class="line"><span>&quot;int&quot;</span></span></code></pre></div><h3 id="persist" tabindex="-1">PERSIST <a class="header-anchor" href="#persist" aria-label="Permalink to &quot;PERSIST&quot;">​</a></h3><p>移除给定 key 的生存时间，将这个 key 从『易失的』(带生存时间 key )转换成『持久的』(一个不带生存时间、永不过期的 key )。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PERSIST key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SET mykey &quot;Hello&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXPIRE mykey 10  # 为 key 设置生存时间</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; TTL mykey</span></span>
<span class="line"><span>(integer) 10</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PERSIST mykey    # 移除 key 的生存时间</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; TTL mykey</span></span>
<span class="line"><span>(integer) -1</span></span></code></pre></div><h3 id="pexpire" tabindex="-1">PEXPIRE <a class="header-anchor" href="#pexpire" aria-label="Permalink to &quot;PEXPIRE&quot;">​</a></h3><p>这个命令和 EXPIRE 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间，而不像 EXPIRE 命令那样，以秒为单位。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PEXPIRE key milliseconds</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SET mykey &quot;Hello&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PEXPIRE mykey 1500</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; TTL mykey    # TTL 的返回值以秒为单位</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PTTL mykey   # PTTL 可以给出准确的毫秒数</span></span>
<span class="line"><span>(integer) 1499</span></span></code></pre></div><h3 id="pexpireat" tabindex="-1">PEXPIREAT <a class="header-anchor" href="#pexpireat" aria-label="Permalink to &quot;PEXPIREAT&quot;">​</a></h3><p>这个命令和 EXPIREAT 命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳，而不是像 EXPIREAT 那样，以秒为单位。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PEXPIREAT key milliseconds-timestamp</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SET mykey &quot;Hello&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PEXPIREAT mykey 1555555555005</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; TTL mykey           # TTL 返回秒</span></span>
<span class="line"><span>(integer) 223157079</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PTTL mykey          # PTTL 返回毫秒</span></span>
<span class="line"><span>(integer) 223157079318</span></span></code></pre></div><h3 id="pttl" tabindex="-1">PTTL <a class="header-anchor" href="#pttl" aria-label="Permalink to &quot;PTTL&quot;">​</a></h3><p>这个命令类似于 TTL 命令，但它以毫秒为单位返回 key 的剩余生存时间，而不是像 TTL 命令那样，以秒为单位。</p><p>Note</p><p>在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PTTL key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 不存在的 key</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; FLUSHDB</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PTTL key</span></span>
<span class="line"><span>(integer) -2</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># key 存在，但没有设置剩余生存时间</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET key value</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PTTL key</span></span>
<span class="line"><span>(integer) -1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 有剩余生存时间的 key</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PEXPIRE key 10086</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PTTL key</span></span>
<span class="line"><span>(integer) 6179</span></span></code></pre></div><h3 id="randomkey" tabindex="-1">RANDOMKEY <a class="header-anchor" href="#randomkey" aria-label="Permalink to &quot;RANDOMKEY&quot;">​</a></h3><p>从当前数据库中随机返回(不删除)一个 key 。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>RANDOMKEY</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 数据库不为空</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; MSET fruit &quot;apple&quot; drink &quot;beer&quot; food &quot;cookies&quot;   # 设置多个 key</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RANDOMKEY</span></span>
<span class="line"><span>&quot;fruit&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RANDOMKEY</span></span>
<span class="line"><span>&quot;food&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; KEYS *    # 查看数据库内所有key，证明 RANDOMKEY 并不删除 key</span></span>
<span class="line"><span>1) &quot;food&quot;</span></span>
<span class="line"><span>2) &quot;drink&quot;</span></span>
<span class="line"><span>3) &quot;fruit&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 数据库为空</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; FLUSHDB  # 删除当前数据库所有 key</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RANDOMKEY</span></span>
<span class="line"><span>(nil)</span></span></code></pre></div><h3 id="rename" tabindex="-1">RENAME <a class="header-anchor" href="#rename" aria-label="Permalink to &quot;RENAME&quot;">​</a></h3><p>将 key 改名为 newkey 。</p><p>当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。</p><p>当 newkey 已经存在时， RENAME 命令将覆盖旧值。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>RENAME key newkey</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># key 存在且 newkey 不存在</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET message &quot;hello world&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RENAME message greeting</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS message               # message 不复存在</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS greeting              # greeting 取而代之</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 当 key 不存在时，返回错误</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RENAME fake_key never_exists</span></span>
<span class="line"><span>(error) ERR no such key</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># newkey 已存在时， RENAME 会覆盖旧 newkey</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET pc &quot;lenovo&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET personal_computer &quot;dell&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RENAME pc personal_computer</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET pc</span></span>
<span class="line"><span>(nil)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis:1&gt; GET personal_computer      # 原来的值 dell 被覆盖了</span></span>
<span class="line"><span>&quot;lenovo&quot;</span></span></code></pre></div><h3 id="renamenx" tabindex="-1">RENAMENX <a class="header-anchor" href="#renamenx" aria-label="Permalink to &quot;RENAMENX&quot;">​</a></h3><p>当且仅当 newkey 不存在时，将 key 改名为 newkey 。</p><p>当 key 不存在时，返回一个错误。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>RENAMENX key newkey</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># newkey 不存在，改名成功</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET player &quot;MPlyaer&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS best_player</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RENAMENX player best_player</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># newkey存在时，失败</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET animal &quot;bear&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET favorite_animal &quot;butterfly&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RENAMENX animal favorite_animal</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; get animal</span></span>
<span class="line"><span>&quot;bear&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; get favorite_animal</span></span>
<span class="line"><span>&quot;butterfly&quot;</span></span></code></pre></div><h3 id="restore" tabindex="-1">RESTORE <a class="header-anchor" href="#restore" aria-label="Permalink to &quot;RESTORE&quot;">​</a></h3><p>反序列化给定的序列化值，并将它和给定的 key 关联。</p><p>参数 ttl 以毫秒为单位为 key 设置生存时间；如果 ttl 为 0 ，那么不设置生存时间。</p><p>RESTORE 在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么 RESTORE 会拒绝进行反序列化，并返回一个错误。</p><p>更多信息可以参考 DUMP 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>RESTORE key ttl serialized-value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SET greeting &quot;hello, dumping world!&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DUMP greeting</span></span>
<span class="line"><span>&quot;\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RESTORE greeting-again 0 &quot;\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET greeting-again</span></span>
<span class="line"><span>&quot;hello, dumping world!&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RESTORE fake-message 0 &quot;hello moto moto blah blah&quot;   ; 使用错误的值进行反序列化</span></span>
<span class="line"><span>(error) ERR DUMP payload version or checksum are wrong</span></span></code></pre></div><h3 id="sort" tabindex="-1">SORT <a class="header-anchor" href="#sort" aria-label="Permalink to &quot;SORT&quot;">​</a></h3><p>返回或保存给定列表、集合、有序集合 key 中经过排序的元素。</p><p>排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。</p><p>最简单的 SORT 使用方法是 SORT key 和 SORT key DESC ：</p><p>假设 today_cost 列表保存了今日的开销金额， 那么可以用 SORT 命令对它进行排序：</p><p>因为 SORT 命令默认排序对象为数字， 当需要对字符串进行排序时， 需要显式地在 SORT 命令之后添加 ALPHA 修饰符：</p><p>如果系统正确地设置了 LC_COLLATE 环境变量的话，Redis能识别 UTF-8 编码。</p><p>排序之后返回元素的数量可以通过 LIMIT 修饰符进行限制， 修饰符接受 offset 和 count 两个参数：</p><p>以下例子返回排序结果的前 5 个对象( offset 为 0 表示没有元素被跳过)。</p><p>可以组合使用多个修饰符。以下例子返回从大到小排序的前 5 个对象。</p><p>可以使用外部 key 的数据作为权重，代替默认的直接对比键值的方式来进行排序。</p><p>假设现在有用户数据如下：</p><p>以下代码将数据输入到 Redis 中：</p><p>默认情况下， SORT uid 直接按 uid 中的值排序：</p><p>通过使用 BY 选项，可以让 uid 按其他键的元素来排序。</p><p>比如说， 以下代码让 uid 键按照 user_level_{uid} 的大小来排序：</p><p>user_level_* 是一个占位符， 它先取出 uid 中的值， 然后再用这个值来查找相应的键。</p><p>比如在对 uid 列表进行排序时， 程序就会先取出 uid 的值 1 、 2 、 3 、 4 ， 然后使用 user_level_1 、 user_level_2 、 user_level_3 和 user_level_4 的值作为排序 uid 的权重。</p><p>使用 GET 选项， 可以根据排序的结果来取出相应的键值。</p><p>比如说， 以下代码先排序 uid ， 再取出键 user_name_{uid} 的值：</p><p>通过组合使用 BY 和 GET ， 可以让排序结果以更直观的方式显示出来。</p><p>比如说， 以下代码先按 user_level_{uid} 来排序 uid 列表， 再取出相应的 user_name_{uid} 的值：</p><p>现在的排序结果要比只使用 SORT uid BY user_level_* 要直观得多。</p><p>可以同时使用多个 GET 选项， 获取多个外部键的值。</p><p>以下代码就按 uid 分别获取 user_level_{uid} 和 user_name_{uid} ：</p><p>GET 有一个额外的参数规则，那就是 —— 可以用 # 获取被排序键的值。</p><p>以下代码就将 uid 的值、及其相应的 user_level_* 和 user_name_* 都返回为结果：</p><p>通过将一个不存在的键作为参数传给 BY 选项， 可以让 SORT 跳过排序操作， 直接返回结果：</p><p>这种用法在单独使用时，没什么实际用处。</p><p>不过，通过将这种用法和 GET 选项配合， 就可以在不排序的情况下， 获取多个外部键， 相当于执行一个整合的获取操作（类似于 SQL 数据库的 join 关键字）。</p><p>以下代码演示了，如何在不引起排序的情况下，使用 SORT 、 BY 和 GET 获取多个外部键：</p><p>除了可以将字符串键之外， 哈希表也可以作为 GET 或 BY 选项的参数来使用。</p><p>比如说，对于前面给出的用户信息表：</p><p>我们可以不将用户的名字和级别保存在 user_name_{uid} 和 user_level_{uid} 两个字符串键中， 而是用一个带有 name 域和 level 域的哈希表 user_info_{uid} 来保存用户的名字和级别信息：</p><p>之后， BY 和 GET 选项都可以用 key-&gt;field 的格式来获取哈希表中的域的值， 其中 key 表示哈希表键， 而 field 则表示哈希表的域：</p><p>默认情况下， SORT 操作只是简单地返回排序结果，并不进行任何保存操作。</p><p>通过给 STORE 选项指定一个 key 参数，可以将排序结果保存到给定的键上。</p><p>如果被指定的 key 已存在，那么原有的值将被排序结果覆盖。</p><p>可以通过将 SORT 命令的执行结果保存，并用 EXPIRE 为结果设置生存时间，以此来产生一个 SORT 操作的结果缓存。</p><p>这样就可以避免对 SORT 操作的频繁调用：只有当结果集过期时，才需要再调用一次 SORT 操作。</p><p>另外，为了正确实现这一用法，你可能需要加锁以避免多个客户端同时进行缓存重建(也就是多个客户端，同一时间进行 SORT 操作，并保存为结果集)，具体参见 SETNX 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC | DESC] [ALPHA] [STORE destination]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 开销金额列表</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH today_cost 30 1.5 10 8</span></span>
<span class="line"><span>(integer) 4</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 排序</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SORT today_cost</span></span>
<span class="line"><span>1) &quot;1.5&quot;</span></span>
<span class="line"><span>2) &quot;8&quot;</span></span>
<span class="line"><span>3) &quot;10&quot;</span></span>
<span class="line"><span>4) &quot;30&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 逆序排序</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SORT today_cost DESC</span></span>
<span class="line"><span>1) &quot;30&quot;</span></span>
<span class="line"><span>2) &quot;10&quot;</span></span>
<span class="line"><span>3) &quot;8&quot;</span></span>
<span class="line"><span>4) &quot;1.5&quot;</span></span></code></pre></div><h3 id="ttl" tabindex="-1">TTL <a class="header-anchor" href="#ttl" aria-label="Permalink to &quot;TTL&quot;">​</a></h3><p>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</p><p>Note</p><p>在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>TTL key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 不存在的 key</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; FLUSHDB</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; TTL key</span></span>
<span class="line"><span>(integer) -2</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># key 存在，但没有设置剩余生存时间</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET key value</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; TTL key</span></span>
<span class="line"><span>(integer) -1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 有剩余生存时间的 key</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXPIRE key 10086</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; TTL key</span></span>
<span class="line"><span>(integer) 10084</span></span></code></pre></div><h3 id="type" tabindex="-1">TYPE <a class="header-anchor" href="#type" aria-label="Permalink to &quot;TYPE&quot;">​</a></h3><p>返回 key 所储存的值的类型。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>TYPE key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 字符串</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET weather &quot;sunny&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; TYPE weather</span></span>
<span class="line"><span>string</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 列表</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH book_list &quot;programming in scala&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; TYPE book_list</span></span>
<span class="line"><span>list</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 集合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SADD pat &quot;dog&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; TYPE pat</span></span>
<span class="line"><span>set</span></span></code></pre></div><h2 id="string-字符串" tabindex="-1">String（字符串） <a class="header-anchor" href="#string-字符串" aria-label="Permalink to &quot;String（字符串）&quot;">​</a></h2><h3 id="append" tabindex="-1">APPEND <a class="header-anchor" href="#append" aria-label="Permalink to &quot;APPEND&quot;">​</a></h3><p>如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。</p><p>如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。</p><p>APPEND 可以为一系列定长(fixed-size)数据(sample)提供一种紧凑的表示方式，通常称之为时间序列。</p><p>每当一个新数据到达的时候，执行以下命令：</p><p>然后可以通过以下的方式访问时间序列的各项属性：</p><p>这个模式的唯一缺陷是我们只能增长时间序列，而不能对时间序列进行缩短，因为 Redis 目前还没有对字符串进行修剪(tirm)的命令，但是，不管怎么说，这个模式的储存方式还是可以节省下大量的空间。</p><p>Note</p><p>可以考虑使用 UNIX 时间戳作为时间序列的键名，这样一来，可以避免单个 key 因为保存过大的时间序列而占用大量内存，另一方面，也可以节省下大量命名空间。</p><p>下面是一个时间序列的例子：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>APPEND key value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 对不存在的 key 执行 APPEND</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS myphone               # 确保 myphone 不存在</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; APPEND myphone &quot;nokia&quot;       # 对不存在的 key 进行 APPEND ，等同于 SET myphone &quot;nokia&quot;</span></span>
<span class="line"><span>(integer) 5                         # 字符长度</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对已存在的字符串进行 APPEND</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; APPEND myphone &quot; - 1110&quot;     # 长度从 5 个字符增加到 12 个字符</span></span>
<span class="line"><span>(integer) 12</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET myphone</span></span>
<span class="line"><span>&quot;nokia - 1110&quot;</span></span></code></pre></div><h3 id="bitcount" tabindex="-1">BITCOUNT <a class="header-anchor" href="#bitcount" aria-label="Permalink to &quot;BITCOUNT&quot;">​</a></h3><p>计算给定字符串中，被设置为 1 的比特位的数量。</p><p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。</p><p>start 和 end 参数的设置和 GETRANGE 命令类似，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推。</p><p>不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。</p><p>Bitmap 对于一些特定类型的计算非常有效。</p><p>假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 SETBIT 和 BITCOUNT 来实现。</p><p>比如说，每当用户在某一天上线的时候，我们就使用 SETBIT ，以用户名作为 key ，将那天所代表的网站的上线日作为 offset 参数，并将这个 offset 上的为设置为 1 。</p><p>举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 SETBIT peter 100 1 ；如果明天 peter 也继续阅览网站，那么执行命令 SETBIT peter 101 1 ，以此类推。</p><p>当要计算 peter 总共以来的上线次数时，就使用 BITCOUNT 命令：执行 BITCOUNT peter ，得出的结果就是 peter 上线的总天数。</p><p>更详细的实现可以参考博文(墙外) Fast, easy, realtime metrics using Redis bitmaps 。</p><p>前面的上线次数统计例子，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， BITCOUNT 的处理速度就像 GET 和 INCR 这种 O(1) 复杂度的操作一样快。</p><p>如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BITCOUNT key [start] [end]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; BITCOUNT bits</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SETBIT bits 0 1          # 0001</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; BITCOUNT bits</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SETBIT bits 3 1          # 1001</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; BITCOUNT bits</span></span>
<span class="line"><span>(integer) 2</span></span></code></pre></div><h3 id="bitop" tabindex="-1">BITOP <a class="header-anchor" href="#bitop" aria-label="Permalink to &quot;BITOP&quot;">​</a></h3><p>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</p><p>operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：</p><p>除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</p><p>处理不同长度的字符串</p><p>当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。</p><p>空的 key 也被看作是包含 0 的字符串序列。</p><p>Note</p><p>BITOP 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BITOP operation destkey key [key ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SETBIT bits-1 0 1        # bits-1 = 1001</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SETBIT bits-1 3 1</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SETBIT bits-2 0 1        # bits-2 = 1011</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SETBIT bits-2 1 1</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SETBIT bits-2 3 1</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; BITOP AND and-result bits-1 bits-2</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETBIT and-result 0      # and-result = 1001</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETBIT and-result 1</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETBIT and-result 2</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETBIT and-result 3</span></span>
<span class="line"><span>(integer) 1</span></span></code></pre></div><h3 id="decr" tabindex="-1">DECR <a class="header-anchor" href="#decr" aria-label="Permalink to &quot;DECR&quot;">​</a></h3><p>将 key 中储存的数字值减一。</p><p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。</p><p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p><p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p><p>关于递增(increment) / 递减(decrement)操作的更多信息，请参见 INCR 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DECR key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 对存在的数字值 key 进行 DECR</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET failure_times 10</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DECR failure_times</span></span>
<span class="line"><span>(integer) 9</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对不存在的 key 值进行 DECR</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS count</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DECR count</span></span>
<span class="line"><span>(integer) -1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对存在但不是数值的 key 进行 DECR</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET company YOUR_CODE_SUCKS.LLC</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DECR company</span></span>
<span class="line"><span>(error) ERR value is not an integer or out of range</span></span></code></pre></div><h3 id="decrby" tabindex="-1">DECRBY <a class="header-anchor" href="#decrby" aria-label="Permalink to &quot;DECRBY&quot;">​</a></h3><p>将 key 所储存的值减去减量 decrement 。</p><p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECRBY 操作。</p><p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p><p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p><p>关于更多递增(increment) / 递减(decrement)操作的更多信息，请参见 INCR 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DECRBY key decrement</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 对已存在的 key 进行 DECRBY</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET count 100</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DECRBY count 20</span></span>
<span class="line"><span>(integer) 80</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对不存在的 key 进行DECRBY</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS pages</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DECRBY pages 10</span></span>
<span class="line"><span>(integer) -10</span></span></code></pre></div><h3 id="get" tabindex="-1">GET <a class="header-anchor" href="#get" aria-label="Permalink to &quot;GET&quot;">​</a></h3><p>返回 key 所关联的字符串值。</p><p>如果 key 不存在那么返回特殊值 nil 。</p><p>假如 key 储存的值不是字符串类型，返回一个错误，因为 GET 只能用于处理字符串值。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GET key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 对不存在的 key 或字符串类型 key 进行 GET</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET db</span></span>
<span class="line"><span>(nil)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET db redis</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET db</span></span>
<span class="line"><span>&quot;redis&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对不是字符串类型的 key 进行 GET</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DEL db</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH db redis mongodb mysql</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET db</span></span>
<span class="line"><span>(error) ERR Operation against a key holding the wrong kind of value</span></span></code></pre></div><h3 id="getbit" tabindex="-1">GETBIT <a class="header-anchor" href="#getbit" aria-label="Permalink to &quot;GETBIT&quot;">​</a></h3><p>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</p><p>当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GETBIT key offset</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS bit</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETBIT bit 10086</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对已存在的 offset 进行 GETBIT</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SETBIT bit 10086 1</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETBIT bit 10086</span></span>
<span class="line"><span>(integer) 1</span></span></code></pre></div><h3 id="getrange" tabindex="-1">GETRANGE <a class="header-anchor" href="#getrange" aria-label="Permalink to &quot;GETRANGE&quot;">​</a></h3><p>返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。</p><p>负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。</p><p>GETRANGE 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</p><p>Note</p><p>在 &lt;= 2.0 的版本里，GETRANGE 被叫作 SUBSTR。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GETRANGE key start end</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SET greeting &quot;hello, my friend&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETRANGE greeting 0 4          # 返回索引0-4的字符，包括4。</span></span>
<span class="line"><span>&quot;hello&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETRANGE greeting -1 -5        # 不支持回绕操作</span></span>
<span class="line"><span>&quot;&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETRANGE greeting -3 -1        # 负数索引</span></span>
<span class="line"><span>&quot;end&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETRANGE greeting 0 -1         # 从第一个到最后一个</span></span>
<span class="line"><span>&quot;hello, my friend&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETRANGE greeting 0 1008611    # 值域范围不超过实际字符串，超过部分自动被符略</span></span>
<span class="line"><span>&quot;hello, my friend&quot;</span></span></code></pre></div><h3 id="getset" tabindex="-1">GETSET <a class="header-anchor" href="#getset" aria-label="Permalink to &quot;GETSET&quot;">​</a></h3><p>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</p><p>当 key 存在但不是字符串类型时，返回一个错误。</p><p>GETSET 可以和 INCR 组合使用，实现一个有原子性(atomic)复位操作的计数器(counter)。</p><p>举例来说，每次当某个事件发生时，进程可能对一个名为 mycount 的 key 调用 INCR 操作，通常我们还要在一个原子时间内同时完成获得计数器的值和将计数器值复位为 0 两个操作。</p><p>可以用命令 GETSET mycounter 0 来实现这一目标。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GETSET key value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; GETSET db mongodb    # 没有旧值，返回 nil</span></span>
<span class="line"><span>(nil)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET db</span></span>
<span class="line"><span>&quot;mongodb&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETSET db redis      # 返回旧值 mongodb</span></span>
<span class="line"><span>&quot;mongodb&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET db</span></span>
<span class="line"><span>&quot;redis&quot;</span></span></code></pre></div><h3 id="incr" tabindex="-1">INCR <a class="header-anchor" href="#incr" aria-label="Permalink to &quot;INCR&quot;">​</a></h3><p>将 key 中储存的数字值增一。</p><p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。</p><p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p><p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p><p>Note</p><p>这是一个针对字符串的操作，因为 Redis 没有专用的整数类型，所以 key 内储存的字符串被解释为十进制 64 位有符号整数来执行 INCR 操作。</p><p>计数器是 Redis 的原子性自增操作可实现的最直观的模式了，它的想法相当简单：每当某个操作发生时，向 Redis 发送一个 INCR 命令。</p><p>比如在一个 web 应用程序中，如果想知道用户在一年中每天的点击量，那么只要将用户 ID 以及相关的日期信息作为键，并在每次用户点击页面时，执行一次自增操作即可。</p><p>比如用户名是 peter ，点击时间是 2012 年 3 月 22 日，那么执行命令 INCR peter::2012.3.22 。</p><p>可以用以下几种方式扩展这个简单的模式：</p><p>限速器是特殊化的计算器，它用于限制一个操作可以被执行的速率(rate)。</p><p>限速器的典型用法是限制公开 API 的请求次数，以下是一个限速器实现示例，它将 API 的最大请求数限制在每个 IP 地址每秒钟十个之内：</p><p>这个实现每秒钟为每个 IP 地址使用一个不同的计数器，并用 EXPIRE 命令设置生存时间(这样 Redis 就会负责自动删除过期的计数器)。</p><p>注意，我们使用事务打包执行 INCR 命令和 EXPIRE 命令，避免引入竞争条件，保证每次调用 API 时都可以正确地对计数器进行自增操作并设置生存时间。</p><p>以下是另一个限速器实现：</p><p>这个限速器只使用单个计数器，它的生存时间为一秒钟，如果在一秒钟内，这个计数器的值大于 10 的话，那么访问就会被禁止。</p><p>这个新的限速器在思路方面是没有问题的，但它在实现方面不够严谨，如果我们仔细观察一下的话，就会发现在 INCR 和 EXPIRE 之间存在着一个竞争条件，假如客户端在执行 INCR 之后，因为某些原因(比如客户端失败)而忘记设置 EXPIRE 的话，那么这个计数器就会一直存在下去，造成每个用户只能访问 10 次，噢，这简直是个灾难！</p><p>要消灭这个实现中的竞争条件，我们可以将它转化为一个 Lua 脚本，并放到 Redis 中运行(这个方法仅限于 Redis 2.6 及以上的版本)：</p><p>通过将计数器作为脚本放到 Redis 上运行，我们保证了 INCR 和 EXPIRE 两个操作的原子性，现在这个脚本实现不会引入竞争条件，它可以运作的很好。</p><p>关于在 Redis 中运行 Lua 脚本的更多信息，请参考 EVAL 命令。</p><p>还有另一种消灭竞争条件的方法，就是使用 Redis 的列表结构来代替 INCR 命令，这个方法无须脚本支持，因此它在 Redis 2.6 以下的版本也可以运行得很好：</p><p>新的限速器使用了列表结构作为容器， LLEN 用于对访问次数进行检查，一个事务包裹着 RPUSH 和 EXPIRE 两个命令，用于在第一次执行计数时创建列表，并正确设置地设置过期时间，最后， RPUSHX 在后续的计数操作中进行增加操作。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>INCR key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SET page_view 20</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCR page_view</span></span>
<span class="line"><span>(integer) 21</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET page_view    # 数字值在 Redis 中以字符串的形式保存</span></span>
<span class="line"><span>&quot;21&quot;</span></span></code></pre></div><h3 id="incrby" tabindex="-1">INCRBY <a class="header-anchor" href="#incrby" aria-label="Permalink to &quot;INCRBY&quot;">​</a></h3><p>将 key 所储存的值加上增量 increment 。</p><p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。</p><p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p><p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p><p>关于递增(increment) / 递减(decrement)操作的更多信息，参见 INCR 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>INCRBY key increment</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># key 存在且是数字值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET rank 50</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCRBY rank 20</span></span>
<span class="line"><span>(integer) 70</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET rank</span></span>
<span class="line"><span>&quot;70&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># key 不存在时</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS counter</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCRBY counter 30</span></span>
<span class="line"><span>(integer) 30</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET counter</span></span>
<span class="line"><span>&quot;30&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># key 不是数字值时</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET book &quot;long long ago...&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCRBY book 200</span></span>
<span class="line"><span>(error) ERR value is not an integer or out of range</span></span></code></pre></div><h3 id="incrbyfloat" tabindex="-1">INCRBYFLOAT <a class="header-anchor" href="#incrbyfloat" aria-label="Permalink to &quot;INCRBYFLOAT&quot;">​</a></h3><p>为 key 中所储存的值加上浮点数增量 increment 。</p><p>如果 key 不存在，那么 INCRBYFLOAT 会先将 key 的值设为 0 ，再执行加法操作。</p><p>如果命令执行成功，那么 key 的值会被更新为（执行加法之后的）新值，并且新值会以字符串的形式返回给调用者。</p><p>无论是 key 的值，还是增量 increment ，都可以使用像 2.0e7 、 3e5 、 90e-2 那样的指数符号(exponential notation)来表示，但是，执行 INCRBYFLOAT 命令之后的值总是以同样的形式储存，也即是，它们总是由一个数字，一个（可选的）小数点和一个任意位的小数部分组成（比如 3.14 、 69.768 ，诸如此类)，小数部分尾随的 0 会被移除，如果有需要的话，还会将浮点数改为整数（比如 3.0 会被保存成 3 ）。</p><p>除此之外，无论加法计算所得的浮点数的实际精度有多长， INCRBYFLOAT 的计算结果也最多只能表示小数点的后十七位。</p><p>当以下任意一个条件发生时，返回一个错误：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>INCRBYFLOAT key increment</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 值和增量都不是指数符号</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET mykey 10.50</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCRBYFLOAT mykey 0.1</span></span>
<span class="line"><span>&quot;10.6&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 值和增量都是指数符号</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET mykey 314e-2</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET mykey                # 用 SET 设置的值可以是指数符号</span></span>
<span class="line"><span>&quot;314e-2&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCRBYFLOAT mykey 0      # 但执行 INCRBYFLOAT 之后格式会被改成非指数符号</span></span>
<span class="line"><span>&quot;3.14&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 可以对整数类型执行</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET mykey 3</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCRBYFLOAT mykey 1.1</span></span>
<span class="line"><span>&quot;4.1&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 后跟的 0 会被移除</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET mykey 3.0</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET mykey                                    # SET 设置的值小数部分可以是 0</span></span>
<span class="line"><span>&quot;3.0&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCRBYFLOAT mykey 1.000000000000000000000    # 但 INCRBYFLOAT 会将无用的 0 忽略掉，有需要的话，将浮点变为整数</span></span>
<span class="line"><span>&quot;4&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET mykey</span></span>
<span class="line"><span>&quot;4&quot;</span></span></code></pre></div><h3 id="mget" tabindex="-1">MGET <a class="header-anchor" href="#mget" aria-label="Permalink to &quot;MGET&quot;">​</a></h3><p>返回所有(一个或多个)给定 key 的值。</p><p>如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MGET key [key ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SET redis redis.com</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET mongodb mongodb.org</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; MGET redis mongodb</span></span>
<span class="line"><span>1) &quot;redis.com&quot;</span></span>
<span class="line"><span>2) &quot;mongodb.org&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; MGET redis mongodb mysql     # 不存在的 mysql 返回 nil</span></span>
<span class="line"><span>1) &quot;redis.com&quot;</span></span>
<span class="line"><span>2) &quot;mongodb.org&quot;</span></span>
<span class="line"><span>3) (nil)</span></span></code></pre></div><h3 id="mset" tabindex="-1">MSET <a class="header-anchor" href="#mset" aria-label="Permalink to &quot;MSET&quot;">​</a></h3><p>同时设置一个或多个 key-value 对。</p><p>如果某个给定 key 已经存在，那么 MSET 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 MSETNX 命令：它只会在所有给定 key 都不存在的情况下进行设置操作。</p><p>MSET 是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，某些给定 key 被更新而另一些给定 key 没有改变的情况，不可能发生。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MSET key value [key value ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; MSET date &quot;2012.3.30&quot; time &quot;11:00 a.m.&quot; weather &quot;sunny&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; MGET date time weather</span></span>
<span class="line"><span>1) &quot;2012.3.30&quot;</span></span>
<span class="line"><span>2) &quot;11:00 a.m.&quot;</span></span>
<span class="line"><span>3) &quot;sunny&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># MSET 覆盖旧值例子</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET google &quot;google.hk&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; MSET google &quot;google.com&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET google</span></span>
<span class="line"><span>&quot;google.com&quot;</span></span></code></pre></div><h3 id="msetnx" tabindex="-1">MSETNX <a class="header-anchor" href="#msetnx" aria-label="Permalink to &quot;MSETNX&quot;">​</a></h3><p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p><p>即使只有一个给定 key 已存在， MSETNX 也会拒绝执行所有给定 key 的设置操作。</p><p>MSETNX 是原子性的，因此它可以用作设置多个不同 key 表示不同字段(field)的唯一性逻辑对象(unique logic object)，所有字段要么全被设置，要么全不被设置。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MSETNX key value [key value ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 对不存在的 key 进行 MSETNX</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; MSETNX rmdbs &quot;MySQL&quot; nosql &quot;MongoDB&quot; key-value-store &quot;redis&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; MGET rmdbs nosql key-value-store</span></span>
<span class="line"><span>1) &quot;MySQL&quot;</span></span>
<span class="line"><span>2) &quot;MongoDB&quot;</span></span>
<span class="line"><span>3) &quot;redis&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># MSET 的给定 key 当中有已存在的 key</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; MSETNX rmdbs &quot;Sqlite&quot; language &quot;python&quot;  # rmdbs 键已经存在，操作失败</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS language                          # 因为 MSET 是原子性操作，language 没有被设置</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET rmdbs                                # rmdbs 也没有被修改</span></span>
<span class="line"><span>&quot;MySQL&quot;</span></span></code></pre></div><h3 id="psetex" tabindex="-1">PSETEX <a class="header-anchor" href="#psetex" aria-label="Permalink to &quot;PSETEX&quot;">​</a></h3><p>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PSETEX key milliseconds value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; PSETEX mykey 1000 &quot;Hello&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PTTL mykey</span></span>
<span class="line"><span>(integer) 999</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET mykey</span></span>
<span class="line"><span>&quot;Hello&quot;</span></span></code></pre></div><h3 id="set" tabindex="-1">SET <a class="header-anchor" href="#set" aria-label="Permalink to &quot;SET&quot;">​</a></h3><p>将字符串值 value 关联到 key 。</p><p>如果 key 已经持有其他值， SET 就覆写旧值，无视类型。</p><p>对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。</p><p>可选参数</p><p>从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</p><p>Note</p><p>因为 SET 命令可以通过参数来实现和 SETNX 、 SETEX 和 PSETEX 三个命令的效果，所以将来的 Redis 版本可能会废弃并最终移除 SETNX 、 SETEX 和 PSETEX 这三个命令。</p><p>在 Redis 2.6.12 版本以前， SET 命令总是返回 OK 。</p><p>命令 SET resource-name anystring NX EX max-lock-time 是一种在 Redis 中实现锁的简单方法。</p><p>客户端执行以上的命令：</p><p>设置的过期时间到达之后，锁将自动释放。</p><p>可以通过以下修改，让这个锁实现更健壮：</p><p>这两个改动可以防止持有过期锁的客户端误删现有锁的情况出现。</p><p>以下是一个简单的解锁脚本示例：</p><p>这个脚本可以通过 EVAL ...script... 1 resource-name token-value 命令来调用。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SET key value [EX seconds] [PX milliseconds] [NX|XX]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 对不存在的键进行设置</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET key &quot;value&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; GET key</span></span>
<span class="line"><span>&quot;value&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对已存在的键进行设置</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET key &quot;new-value&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; GET key</span></span>
<span class="line"><span>&quot;new-value&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 使用 EX 选项</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET key-with-expire-time &quot;hello&quot; EX 10086</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; GET key-with-expire-time</span></span>
<span class="line"><span>&quot;hello&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; TTL key-with-expire-time</span></span>
<span class="line"><span>(integer) 10069</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 使用 PX 选项</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET key-with-pexpire-time &quot;moto&quot; PX 123321</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; GET key-with-pexpire-time</span></span>
<span class="line"><span>&quot;moto&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; PTTL key-with-pexpire-time</span></span>
<span class="line"><span>(integer) 111939</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 使用 NX 选项</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET not-exists-key &quot;value&quot; NX</span></span>
<span class="line"><span>OK      # 键不存在，设置成功</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; GET not-exists-key</span></span>
<span class="line"><span>&quot;value&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET not-exists-key &quot;new-value&quot; NX</span></span>
<span class="line"><span>(nil)   # 键已经存在，设置失败</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; GEt not-exists-key</span></span>
<span class="line"><span>&quot;value&quot; # 维持原值不变</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 使用 XX 选项</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; EXISTS exists-key</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET exists-key &quot;value&quot; XX</span></span>
<span class="line"><span>(nil)   # 因为键不存在，设置失败</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET exists-key &quot;value&quot;</span></span>
<span class="line"><span>OK      # 先给键设置一个值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET exists-key &quot;new-value&quot; XX</span></span>
<span class="line"><span>OK      # 设置新值成功</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; GET exists-key</span></span>
<span class="line"><span>&quot;new-value&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># NX 或 XX 可以和 EX 或者 PX 组合使用</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET key-with-expire-and-NX &quot;hello&quot; EX 10086 NX</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; GET key-with-expire-and-NX</span></span>
<span class="line"><span>&quot;hello&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; TTL key-with-expire-and-NX</span></span>
<span class="line"><span>(integer) 10063</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET key-with-pexpire-and-XX &quot;old value&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET key-with-pexpire-and-XX &quot;new value&quot; PX 123321</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; GET key-with-pexpire-and-XX</span></span>
<span class="line"><span>&quot;new value&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; PTTL key-with-pexpire-and-XX</span></span>
<span class="line"><span>(integer) 112999</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># EX 和 PX 可以同时出现，但后面给出的选项会覆盖前面给出的选项</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET key &quot;value&quot; EX 1000 PX 5000000</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; TTL key</span></span>
<span class="line"><span>(integer) 4993  # 这是 PX 参数设置的值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SET another-key &quot;value&quot; PX 5000000 EX 1000</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; TTL another-key</span></span>
<span class="line"><span>(integer) 997   # 这是 EX 参数设置的值</span></span></code></pre></div><h3 id="setbit" tabindex="-1">SETBIT <a class="header-anchor" href="#setbit" aria-label="Permalink to &quot;SETBIT&quot;">​</a></h3><p>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</p><p>位的设置或清除取决于 value 参数，可以是 0 也可以是 1 。</p><p>当 key 不存在时，自动生成一个新的字符串值。</p><p>字符串会进行伸展(grown)以确保它可以将 value 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 0 填充。</p><p>offset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。</p><p>Warning</p><p>对使用大的 offset 的 SETBIT 操作来说，内存分配可能造成 Redis 服务器被阻塞。具体参考 SETRANGE 命令，warning(警告)部分。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SETBIT key offset value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SETBIT bit 10086 1</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETBIT bit 10086</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GETBIT bit 100   # bit 默认被初始化为 0</span></span>
<span class="line"><span>(integer) 0</span></span></code></pre></div><h3 id="setex" tabindex="-1">SETEX <a class="header-anchor" href="#setex" aria-label="Permalink to &quot;SETEX&quot;">​</a></h3><p>将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。</p><p>如果 key 已经存在， SETEX 命令将覆写旧值。</p><p>这个命令类似于以下两个命令：</p><p>不同之处是， SETEX 是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成，该命令在 Redis 用作缓存时，非常实用。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SETEX key seconds value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SET key value</span></span>
<span class="line"><span>EXPIRE key seconds  # 设置生存时间</span></span></code></pre></div><h3 id="setnx" tabindex="-1">SETNX <a class="header-anchor" href="#setnx" aria-label="Permalink to &quot;SETNX&quot;">​</a></h3><p>将 key 的值设为 value ，当且仅当 key 不存在。</p><p>若给定的 key 已经存在，则 SETNX 不做任何动作。</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SETNX key value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; EXISTS job                # job 不存在</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SETNX job &quot;programmer&quot;    # job 设置成功</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SETNX job &quot;code-farmer&quot;   # 尝试覆盖 job ，失败</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET job                   # 没有被覆盖</span></span>
<span class="line"><span>&quot;programmer&quot;</span></span></code></pre></div><h3 id="setrange" tabindex="-1">SETRANGE <a class="header-anchor" href="#setrange" aria-label="Permalink to &quot;SETRANGE&quot;">​</a></h3><p>用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。</p><p>不存在的 key 当作空白字符串处理。</p><p>SETRANGE 命令会确保字符串足够长以便将 value 设置在指定的偏移量上，如果给定 key 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 offset 是 10 )，那么原字符和偏移量之间的空白将用零字节(zerobytes, &quot;\\x00&quot; )来填充。</p><p>注意你能使用的最大偏移量是 2^29-1(536870911) ，因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内。如果你需要使用比这更大的空间，你可以使用多个 key 。</p><p>Warning</p><p>当生成一个很长的字符串时，Redis 需要分配内存空间，该操作有时候可能会造成服务器阻塞(block)。在2010年的Macbook Pro上，设置偏移量为 536870911(512MB 内存分配)，耗费约 300 毫秒， 设置偏移量为 134217728(128MB 内存分配)，耗费约 80 毫秒，设置偏移量 33554432(32MB 内存分配)，耗费约 30 毫秒，设置偏移量为 8388608(8MB 内存分配)，耗费约 8 毫秒。 注意若首次内存分配成功之后，再对同一个 key 调用 SETRANGE 操作，无须再重新内存。</p><p>因为有了 SETRANGE 和 GETRANGE 命令，你可以将 Redis 字符串用作具有O(1)随机访问时间的线性数组，这在很多真实用例中都是非常快速且高效的储存方式，具体请参考 APPEND 命令的『模式：时间序列』部分。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SETRANGE key offset value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 对非空字符串进行 SETRANGE</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET greeting &quot;hello world&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SETRANGE greeting 6 &quot;Redis&quot;</span></span>
<span class="line"><span>(integer) 11</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET greeting</span></span>
<span class="line"><span>&quot;hello Redis&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对空字符串/不存在的 key 进行 SETRANGE</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS empty_string</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SETRANGE empty_string 5 &quot;Redis!&quot;   # 对不存在的 key 使用 SETRANGE</span></span>
<span class="line"><span>(integer) 11</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; GET empty_string                   # 空白处被&quot;\\x00&quot;填充</span></span>
<span class="line"><span>&quot;\\x00\\x00\\x00\\x00\\x00Redis!&quot;</span></span></code></pre></div><h3 id="strlen" tabindex="-1">STRLEN <a class="header-anchor" href="#strlen" aria-label="Permalink to &quot;STRLEN&quot;">​</a></h3><p>返回 key 所储存的字符串值的长度。</p><p>当 key 储存的不是字符串值时，返回一个错误。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>STRLEN key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 获取字符串的长度</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET mykey &quot;Hello world&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; STRLEN mykey</span></span>
<span class="line"><span>(integer) 11</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 不存在的 key 长度为 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; STRLEN nonexisting</span></span>
<span class="line"><span>(integer) 0</span></span></code></pre></div><h2 id="hash-哈希表" tabindex="-1">Hash（哈希表） <a class="header-anchor" href="#hash-哈希表" aria-label="Permalink to &quot;Hash（哈希表）&quot;">​</a></h2><h3 id="hdel" tabindex="-1">HDEL <a class="header-anchor" href="#hdel" aria-label="Permalink to &quot;HDEL&quot;">​</a></h3><p>删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。</p><p>Note</p><p>在Redis2.4以下的版本里， HDEL 每次只能删除单个域，如果你需要在一个原子时间内删除多个域，请将命令包含在 MULTI / EXEC 块内。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HDEL key field [field ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 测试数据</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HGETALL abbr</span></span>
<span class="line"><span>1) &quot;a&quot;</span></span>
<span class="line"><span>2) &quot;apple&quot;</span></span>
<span class="line"><span>3) &quot;b&quot;</span></span>
<span class="line"><span>4) &quot;banana&quot;</span></span>
<span class="line"><span>5) &quot;c&quot;</span></span>
<span class="line"><span>6) &quot;cat&quot;</span></span>
<span class="line"><span>7) &quot;d&quot;</span></span>
<span class="line"><span>8) &quot;dog&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 删除单个域</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HDEL abbr a</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 删除不存在的域</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HDEL abbr not-exists-field</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 删除多个域</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HDEL abbr b c</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HGETALL abbr</span></span>
<span class="line"><span>1) &quot;d&quot;</span></span>
<span class="line"><span>2) &quot;dog&quot;</span></span></code></pre></div><h3 id="hexists" tabindex="-1">HEXISTS <a class="header-anchor" href="#hexists" aria-label="Permalink to &quot;HEXISTS&quot;">​</a></h3><p>查看哈希表 key 中，给定域 field 是否存在。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HEXISTS key field</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; HEXISTS phone myphone</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HSET phone myphone nokia-1110</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HEXISTS phone myphone</span></span>
<span class="line"><span>(integer) 1</span></span></code></pre></div><h3 id="hget" tabindex="-1">HGET <a class="header-anchor" href="#hget" aria-label="Permalink to &quot;HGET&quot;">​</a></h3><p>返回哈希表 key 中给定域 field 的值。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HGET key field</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 域存在</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HSET site redis redis.com</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HGET site redis</span></span>
<span class="line"><span>&quot;redis.com&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 域不存在</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HGET site mysql</span></span>
<span class="line"><span>(nil)</span></span></code></pre></div><h3 id="hgetall" tabindex="-1">HGETALL <a class="header-anchor" href="#hgetall" aria-label="Permalink to &quot;HGETALL&quot;">​</a></h3><p>返回哈希表 key 中，所有的域和值。</p><p>在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HGETALL key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; HSET people jack &quot;Jack Sparrow&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HSET people gump &quot;Forrest Gump&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HGETALL people</span></span>
<span class="line"><span>1) &quot;jack&quot;          # 域</span></span>
<span class="line"><span>2) &quot;Jack Sparrow&quot;  # 值</span></span>
<span class="line"><span>3) &quot;gump&quot;</span></span>
<span class="line"><span>4) &quot;Forrest Gump&quot;</span></span></code></pre></div><h3 id="hincrby" tabindex="-1">HINCRBY <a class="header-anchor" href="#hincrby" aria-label="Permalink to &quot;HINCRBY&quot;">​</a></h3><p>为哈希表 key 中的域 field 的值加上增量 increment 。</p><p>增量也可以为负数，相当于对给定域进行减法操作。</p><p>如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。</p><p>如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。</p><p>对一个储存字符串值的域 field 执行 HINCRBY 命令将造成一个错误。</p><p>本操作的值被限制在 64 位(bit)有符号数字表示之内。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HINCRBY key field increment</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># increment 为正数</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HEXISTS counter page_view    # 对空域进行设置</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HINCRBY counter page_view 200</span></span>
<span class="line"><span>(integer) 200</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HGET counter page_view</span></span>
<span class="line"><span>&quot;200&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># increment 为负数</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HGET counter page_view</span></span>
<span class="line"><span>&quot;200&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HINCRBY counter page_view -50</span></span>
<span class="line"><span>(integer) 150</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HGET counter page_view</span></span>
<span class="line"><span>&quot;150&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 尝试对字符串值的域执行HINCRBY命令</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HSET myhash string hello,world       # 设定一个字符串值</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HGET myhash string</span></span>
<span class="line"><span>&quot;hello,world&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HINCRBY myhash string 1              # 命令执行失败，错误。</span></span>
<span class="line"><span>(error) ERR hash value is not an integer</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HGET myhash string                   # 原值不变</span></span>
<span class="line"><span>&quot;hello,world&quot;</span></span></code></pre></div><h3 id="hincrbyfloat" tabindex="-1">HINCRBYFLOAT <a class="header-anchor" href="#hincrbyfloat" aria-label="Permalink to &quot;HINCRBYFLOAT&quot;">​</a></h3><p>为哈希表 key 中的域 field 加上浮点数增量 increment 。</p><p>如果哈希表中没有域 field ，那么 HINCRBYFLOAT 会先将域 field 的值设为 0 ，然后再执行加法操作。</p><p>如果键 key 不存在，那么 HINCRBYFLOAT 会先创建一个哈希表，再创建域 field ，最后再执行加法操作。</p><p>当以下任意一个条件发生时，返回一个错误：</p><p>HINCRBYFLOAT 命令的详细功能和 INCRBYFLOAT 命令类似，请查看 INCRBYFLOAT 命令获取更多相关信息。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HINCRBYFLOAT key field increment</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 值和增量都是普通小数</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HSET mykey field 10.50</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis&gt; HINCRBYFLOAT mykey field 0.1</span></span>
<span class="line"><span>&quot;10.6&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 值和增量都是指数符号</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HSET mykey field 5.0e3</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span>redis&gt; HINCRBYFLOAT mykey field 2.0e2</span></span>
<span class="line"><span>&quot;5200&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对不存在的键执行 HINCRBYFLOAT</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS price</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span>redis&gt; HINCRBYFLOAT price milk 3.5</span></span>
<span class="line"><span>&quot;3.5&quot;</span></span>
<span class="line"><span>redis&gt; HGETALL price</span></span>
<span class="line"><span>1) &quot;milk&quot;</span></span>
<span class="line"><span>2) &quot;3.5&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对不存在的域进行 HINCRBYFLOAT</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HGETALL price</span></span>
<span class="line"><span>1) &quot;milk&quot;</span></span>
<span class="line"><span>2) &quot;3.5&quot;</span></span>
<span class="line"><span>redis&gt; HINCRBYFLOAT price coffee 4.5   # 新增 coffee 域</span></span>
<span class="line"><span>&quot;4.5&quot;</span></span>
<span class="line"><span>redis&gt; HGETALL price</span></span>
<span class="line"><span>1) &quot;milk&quot;</span></span>
<span class="line"><span>2) &quot;3.5&quot;</span></span>
<span class="line"><span>3) &quot;coffee&quot;</span></span>
<span class="line"><span>4) &quot;4.5&quot;</span></span></code></pre></div><h3 id="hkeys" tabindex="-1">HKEYS <a class="header-anchor" href="#hkeys" aria-label="Permalink to &quot;HKEYS&quot;">​</a></h3><p>返回哈希表 key 中的所有域。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HKEYS key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 哈希表非空</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HKEYS website</span></span>
<span class="line"><span>1) &quot;google&quot;</span></span>
<span class="line"><span>2) &quot;yahoo&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 空哈希表/key不存在</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS fake_key</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HKEYS fake_key</span></span>
<span class="line"><span>(empty list or set)</span></span></code></pre></div><h3 id="hlen" tabindex="-1">HLEN <a class="header-anchor" href="#hlen" aria-label="Permalink to &quot;HLEN&quot;">​</a></h3><p>返回哈希表 key 中域的数量。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HLEN key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; HSET db redis redis.com</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HSET db mysql mysql.com</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HLEN db</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HSET db mongodb mongodb.org</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HLEN db</span></span>
<span class="line"><span>(integer) 3</span></span></code></pre></div><h3 id="hmget" tabindex="-1">HMGET <a class="header-anchor" href="#hmget" aria-label="Permalink to &quot;HMGET&quot;">​</a></h3><p>返回哈希表 key 中，一个或多个给定域的值。</p><p>如果给定的域不存在于哈希表，那么返回一个 nil 值。</p><p>因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HMGET key field [field ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; HMSET pet dog &quot;doudou&quot; cat &quot;nounou&quot;    # 一次设置多个域</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HMGET pet dog cat fake_pet             # 返回值的顺序和传入参数的顺序一样</span></span>
<span class="line"><span>1) &quot;doudou&quot;</span></span>
<span class="line"><span>2) &quot;nounou&quot;</span></span>
<span class="line"><span>3) (nil)                                      # 不存在的域返回nil值</span></span></code></pre></div><h3 id="hmset" tabindex="-1">HMSET <a class="header-anchor" href="#hmset" aria-label="Permalink to &quot;HMSET&quot;">​</a></h3><p>同时将多个 field-value (域-值)对设置到哈希表 key 中。</p><p>此命令会覆盖哈希表中已存在的域。</p><p>如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HMSET key field value [field value ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HGET website google</span></span>
<span class="line"><span>&quot;www.google.com&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HGET website yahoo</span></span>
<span class="line"><span>&quot;www.yahoo.com&quot;</span></span></code></pre></div><h3 id="hset" tabindex="-1">HSET <a class="header-anchor" href="#hset" aria-label="Permalink to &quot;HSET&quot;">​</a></h3><p>将哈希表 key 中的域 field 的值设为 value 。</p><p>如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。</p><p>如果域 field 已经存在于哈希表中，旧值将被覆盖。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HSET key field value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; HSET website google &quot;www.g.cn&quot;       # 设置一个新域</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HSET website google &quot;www.google.com&quot; # 覆盖一个旧域</span></span>
<span class="line"><span>(integer) 0</span></span></code></pre></div><h3 id="hsetnx" tabindex="-1">HSETNX <a class="header-anchor" href="#hsetnx" aria-label="Permalink to &quot;HSETNX&quot;">​</a></h3><p>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在。</p><p>若域 field 已经存在，该操作无效。</p><p>如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HSETNX key field value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; HSETNX nosql key-value-store redis</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HSETNX nosql key-value-store redis       # 操作无效，域 key-value-store 已存在</span></span>
<span class="line"><span>(integer) 0</span></span></code></pre></div><h3 id="hvals" tabindex="-1">HVALS <a class="header-anchor" href="#hvals" aria-label="Permalink to &quot;HVALS&quot;">​</a></h3><p>返回哈希表 key 中所有域的值。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HVALS key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 非空哈希表</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HVALS website</span></span>
<span class="line"><span>1) &quot;www.google.com&quot;</span></span>
<span class="line"><span>2) &quot;www.yahoo.com&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 空哈希表/不存在的key</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS not_exists</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; HVALS not_exists</span></span>
<span class="line"><span>(empty list or set)</span></span></code></pre></div><h3 id="hscan" tabindex="-1">HSCAN <a class="header-anchor" href="#hscan" aria-label="Permalink to &quot;HSCAN&quot;">​</a></h3><h2 id="list-列表" tabindex="-1">List（列表） <a class="header-anchor" href="#list-列表" aria-label="Permalink to &quot;List（列表）&quot;">​</a></h2><h3 id="blpop" tabindex="-1">BLPOP <a class="header-anchor" href="#blpop" aria-label="Permalink to &quot;BLPOP&quot;">​</a></h3><p>BLPOP 是列表的阻塞式(blocking)弹出原语。</p><p>它是 LPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p><p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p><p>非阻塞行为</p><p>当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字一起，组成结果返回给调用者。</p><p>当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。</p><p>假设现在有 job 、 command 和 request 三个列表，其中 job 不存在， command 和 request 都持有非空列表。考虑以下命令：</p><p>BLPOP job command request 0</p><p>BLPOP 保证返回的元素来自 command ，因为它是按”查找 job -&gt; 查找 command -&gt; 查找 request “这样的顺序，第一个找到的非空列表。</p><p>阻塞行为</p><p>如果所有给定 key 都不存在或包含空列表，那么 BLPOP 命令将阻塞连接，直到等待超时，或有另一个客户端对给定 key 的任意一个执行 LPUSH 或 RPUSH 命令为止。</p><p>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。</p><p>相同的key被多个客户端同时阻塞</p><p>相同的 key 可以被多个客户端同时阻塞。</p><p>不同的客户端被放进一个队列中，按『先阻塞先服务』(first-BLPOP，first-served)的顺序为 key 执行 BLPOP 命令。</p><p>在MULTI/EXEC事务中的BLPOP</p><p>BLPOP 可以用于流水线(pipline,批量地发送多个命令并读入多个回复)，但把它用在 MULTI / EXEC 块当中没有意义。因为这要求整个服务器被阻塞以保证块执行时的原子性，该行为阻止了其他客户端执行 LPUSH 或 RPUSH 命令。</p><p>因此，一个被包裹在 MULTI / EXEC 块内的 BLPOP 命令，行为表现得就像 LPOP 一样，对空列表返回 nil ，对非空列表弹出列表元素，不进行任何阻塞操作。</p><p>有时候，为了等待一个新元素到达数据中，需要使用轮询的方式对数据进行探查。</p><p>另一种更好的方式是，使用系统提供的阻塞原语，在新元素到达时立即进行处理，而新元素还没到达时，就一直阻塞住，避免轮询占用资源。</p><p>对于 Redis ，我们似乎需要一个阻塞版的 SPOP 命令，但实际上，使用 BLPOP 或者 BRPOP 就能很好地解决这个问题。</p><p>使用元素的客户端(消费者)可以执行类似以下的代码：</p><p>添加元素的客户端(消费者)则执行以下代码：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BLPOP key [key ...] timeout</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; DEL job command request           # 确保key都被删除</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH command &quot;update system...&quot;  # 为command列表增加一个值</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH request &quot;visit page&quot;        # 为request列表增加一个值</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; BLPOP job command request 0       # job 列表为空，被跳过，紧接着 command 列表的第一个元素被弹出。</span></span>
<span class="line"><span>1) &quot;command&quot;                             # 弹出元素所属的列表</span></span>
<span class="line"><span>2) &quot;update system...&quot;                    # 弹出元素所属的值</span></span></code></pre></div><h3 id="brpop" tabindex="-1">BRPOP <a class="header-anchor" href="#brpop" aria-label="Permalink to &quot;BRPOP&quot;">​</a></h3><p>BRPOP 是列表的阻塞式(blocking)弹出原语。</p><p>它是 RPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p><p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。</p><p>关于阻塞操作的更多信息，请查看 BLPOP 命令， BRPOP 除了弹出元素的位置和 BLPOP 不同之外，其他表现一致。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BRPOP key [key ...] timeout</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; LLEN course</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSH course algorithm001</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSH course c++101</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; BRPOP course 30</span></span>
<span class="line"><span>1) &quot;course&quot;             # 弹出元素的 key</span></span>
<span class="line"><span>2) &quot;c++101&quot;             # 弹出元素的值</span></span></code></pre></div><h3 id="brpoplpush" tabindex="-1">BRPOPLPUSH <a class="header-anchor" href="#brpoplpush" aria-label="Permalink to &quot;BRPOPLPUSH&quot;">​</a></h3><p>BRPOPLPUSH 是 RPOPLPUSH 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH 一样。</p><p>当列表 source 为空时， BRPOPLPUSH 命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行 LPUSH 或 RPUSH 命令为止。</p><p>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。</p><p>更多相关信息，请参考 RPOPLPUSH 命令。</p><p>参考 RPOPLPUSH 命令的『安全队列』模式。</p><p>参考 RPOPLPUSH 命令的『循环列表』模式。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BRPOPLPUSH source destination timeout</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 非空列表</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; BRPOPLPUSH msg reciver 500</span></span>
<span class="line"><span>&quot;hello moto&quot;                        # 弹出元素的值</span></span>
<span class="line"><span>(3.38s)                             # 等待时长</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LLEN reciver</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE reciver 0 0</span></span>
<span class="line"><span>1) &quot;hello moto&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 空列表</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; BRPOPLPUSH msg reciver 1</span></span>
<span class="line"><span>(nil)</span></span>
<span class="line"><span>(1.34s)</span></span></code></pre></div><h3 id="lindex" tabindex="-1">LINDEX <a class="header-anchor" href="#lindex" aria-label="Permalink to &quot;LINDEX&quot;">​</a></h3><p>返回列表 key 中，下标为 index 的元素。</p><p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p><p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p>如果 key 不是列表类型，返回一个错误。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LINDEX key index</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; LPUSH mylist &quot;World&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH mylist &quot;Hello&quot;</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LINDEX mylist 0</span></span>
<span class="line"><span>&quot;Hello&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LINDEX mylist -1</span></span>
<span class="line"><span>&quot;World&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LINDEX mylist 3        # index不在 mylist 的区间范围内</span></span>
<span class="line"><span>(nil)</span></span></code></pre></div><h3 id="linsert" tabindex="-1">LINSERT <a class="header-anchor" href="#linsert" aria-label="Permalink to &quot;LINSERT&quot;">​</a></h3><p>将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</p><p>当 pivot 不存在于列表 key 时，不执行任何操作。</p><p>当 key 不存在时， key 被视为空列表，不执行任何操作。</p><p>如果 key 不是列表类型，返回一个错误。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LINSERT key BEFORE|AFTER pivot value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; RPUSH mylist &quot;Hello&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSH mylist &quot;World&quot;</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LINSERT mylist BEFORE &quot;World&quot; &quot;There&quot;</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE mylist 0 -1</span></span>
<span class="line"><span>1) &quot;Hello&quot;</span></span>
<span class="line"><span>2) &quot;There&quot;</span></span>
<span class="line"><span>3) &quot;World&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对一个非空列表插入，查找一个不存在的 pivot</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LINSERT mylist BEFORE &quot;go&quot; &quot;let&#39;s&quot;</span></span>
<span class="line"><span>(integer) -1                                    # 失败</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对一个空列表执行 LINSERT 命令</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS fake_list</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LINSERT fake_list BEFORE &quot;nono&quot; &quot;gogogog&quot;</span></span>
<span class="line"><span>(integer) 0                                      # 失败</span></span></code></pre></div><h3 id="llen" tabindex="-1">LLEN <a class="header-anchor" href="#llen" aria-label="Permalink to &quot;LLEN&quot;">​</a></h3><p>返回列表 key 的长度。</p><p>如果 key 不存在，则 key 被解释为一个空列表，返回 0 .</p><p>如果 key 不是列表类型，返回一个错误。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LLEN key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 空列表</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LLEN job</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 非空列表</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH job &quot;cook food&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH job &quot;have lunch&quot;</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LLEN job</span></span>
<span class="line"><span>(integer) 2</span></span></code></pre></div><h3 id="lpop" tabindex="-1">LPOP <a class="header-anchor" href="#lpop" aria-label="Permalink to &quot;LPOP&quot;">​</a></h3><p>移除并返回列表 key 的头元素。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LPOP key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; LLEN course</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSH course algorithm001</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSH course c++101</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPOP course  # 移除头元素</span></span>
<span class="line"><span>&quot;algorithm001&quot;</span></span></code></pre></div><h3 id="lpush" tabindex="-1">LPUSH <a class="header-anchor" href="#lpush" aria-label="Permalink to &quot;LPUSH&quot;">​</a></h3><p>将一个或多个值 value 插入到列表 key 的表头</p><p>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头： 比如说，对空列表 mylist 执行命令 LPUSH mylist a b c ，列表的值将是 c b a ，这等同于原子性地执行 LPUSH mylist a 、 LPUSH mylist b 和 LPUSH mylist c 三个命令。</p><p>如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。</p><p>当 key 存在但不是列表类型时，返回一个错误。</p><p>Note</p><p>在Redis 2.4版本以前的 LPUSH 命令，都只接受单个 value 值。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LPUSH key value [value ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 加入单个元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH languages python</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 加入重复元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH languages python</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE languages 0 -1     # 列表允许重复元素</span></span>
<span class="line"><span>1) &quot;python&quot;</span></span>
<span class="line"><span>2) &quot;python&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 加入多个元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH mylist a b c</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE mylist 0 -1</span></span>
<span class="line"><span>1) &quot;c&quot;</span></span>
<span class="line"><span>2) &quot;b&quot;</span></span>
<span class="line"><span>3) &quot;a&quot;</span></span></code></pre></div><h3 id="lpushx" tabindex="-1">LPUSHX <a class="header-anchor" href="#lpushx" aria-label="Permalink to &quot;LPUSHX&quot;">​</a></h3><p>将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。</p><p>和 LPUSH 命令相反，当 key 不存在时， LPUSHX 命令什么也不做。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LPUSHX key value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 对空列表执行 LPUSHX</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LLEN greet                       # greet 是一个空列表</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSHX greet &quot;hello&quot;             # 尝试 LPUSHX，失败，因为列表为空</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对非空列表执行 LPUSHX</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH greet &quot;hello&quot;              # 先用 LPUSH 创建一个有一个元素的列表</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSHX greet &quot;good morning&quot;      # 这次 LPUSHX 执行成功</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE greet 0 -1</span></span>
<span class="line"><span>1) &quot;good morning&quot;</span></span>
<span class="line"><span>2) &quot;hello&quot;</span></span></code></pre></div><h3 id="lrange" tabindex="-1">LRANGE <a class="header-anchor" href="#lrange" aria-label="Permalink to &quot;LRANGE&quot;">​</a></h3><p>返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。</p><p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p><p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p>注意LRANGE命令和编程语言区间函数的区别</p><p>假如你有一个包含一百个元素的列表，对该列表执行 LRANGE list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LRANGE 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array#slice 和Python的 range() 函数。</p><p>超出范围的下标</p><p>超出范围的下标值不会引起错误。</p><p>如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，那么 LRANGE 返回一个空列表。</p><p>如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LRANGE key start stop</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; RPUSH fp-language lisp</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE fp-language 0 0</span></span>
<span class="line"><span>1) &quot;lisp&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSH fp-language scheme</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE fp-language 0 1</span></span>
<span class="line"><span>1) &quot;lisp&quot;</span></span>
<span class="line"><span>2) &quot;scheme&quot;</span></span></code></pre></div><h3 id="lrem" tabindex="-1">LREM <a class="header-anchor" href="#lrem" aria-label="Permalink to &quot;LREM&quot;">​</a></h3><p>根据参数 count 的值，移除列表中与参数 value 相等的元素。</p><p>count 的值可以是以下几种：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LREM key count value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 先创建一个表，内容排列是</span></span>
<span class="line"><span># morning hello morning helllo morning</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH greet &quot;morning&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis&gt; LPUSH greet &quot;hello&quot;</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span>redis&gt; LPUSH greet &quot;morning&quot;</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span>redis&gt; LPUSH greet &quot;hello&quot;</span></span>
<span class="line"><span>(integer) 4</span></span>
<span class="line"><span>redis&gt; LPUSH greet &quot;morning&quot;</span></span>
<span class="line"><span>(integer) 5</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE greet 0 4         # 查看所有元素</span></span>
<span class="line"><span>1) &quot;morning&quot;</span></span>
<span class="line"><span>2) &quot;hello&quot;</span></span>
<span class="line"><span>3) &quot;morning&quot;</span></span>
<span class="line"><span>4) &quot;hello&quot;</span></span>
<span class="line"><span>5) &quot;morning&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LREM greet 2 morning     # 移除从表头到表尾，最先发现的两个 morning</span></span>
<span class="line"><span>(integer) 2                     # 两个元素被移除</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LLEN greet               # 还剩 3 个元素</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE greet 0 2</span></span>
<span class="line"><span>1) &quot;hello&quot;</span></span>
<span class="line"><span>2) &quot;hello&quot;</span></span>
<span class="line"><span>3) &quot;morning&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LREM greet -1 morning    # 移除从表尾到表头，第一个 morning</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LLEN greet               # 剩下两个元素</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE greet 0 1</span></span>
<span class="line"><span>1) &quot;hello&quot;</span></span>
<span class="line"><span>2) &quot;hello&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LREM greet 0 hello      # 移除表中所有 hello</span></span>
<span class="line"><span>(integer) 2                    # 两个 hello 被移除</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LLEN greet</span></span>
<span class="line"><span>(integer) 0</span></span></code></pre></div><h3 id="lset" tabindex="-1">LSET <a class="header-anchor" href="#lset" aria-label="Permalink to &quot;LSET&quot;">​</a></h3><p>将列表 key 下标为 index 的元素的值设置为 value 。</p><p>当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</p><p>关于列表下标的更多信息，请参考 LINDEX 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LSET key index value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 对空列表(key 不存在)进行 LSET</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS list</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LSET list 0 item</span></span>
<span class="line"><span>(error) ERR no such key</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 对非空列表进行 LSET</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LPUSH job &quot;cook food&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE job 0 0</span></span>
<span class="line"><span>1) &quot;cook food&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LSET job 0 &quot;play game&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE job  0 0</span></span>
<span class="line"><span>1) &quot;play game&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># index 超出范围</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LLEN list                    # 列表长度为 1</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LSET list 3 &#39;out of range&#39;</span></span>
<span class="line"><span>(error) ERR index out of range</span></span></code></pre></div><h3 id="ltrim" tabindex="-1">LTRIM <a class="header-anchor" href="#ltrim" aria-label="Permalink to &quot;LTRIM&quot;">​</a></h3><p>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p><p>举个例子，执行命令 LTRIM list 0 2 ，表示只保留列表 list 的前三个元素，其余元素全部删除。</p><p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p><p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p>当 key 不是列表类型时，返回一个错误。</p><p>LTRIM 命令通常和 LPUSH 命令或 RPUSH 命令配合使用，举个例子：</p><p>这个例子模拟了一个日志程序，每次将最新日志 newest_log 放到 log 列表中，并且只保留最新的 100 项。注意当这样使用 LTRIM 命令时，时间复杂度是O(1)，因为平均情况下，每次只有一个元素被移除。</p><p>注意LTRIM命令和编程语言区间函数的区别</p><p>假如你有一个包含一百个元素的列表 list ，对该列表执行 LTRIM list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LTRIM 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array#slice 和Python的 range() 函数。</p><p>超出范围的下标</p><p>超出范围的下标值不会引起错误。</p><p>如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，或者 start &gt; stop ， LTRIM 返回一个空列表(因为 LTRIM 已经将整个列表清空)。</p><p>如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LTRIM key start stop</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LPUSH log newest_log</span></span>
<span class="line"><span>LTRIM log 0 99</span></span></code></pre></div><h3 id="rpop" tabindex="-1">RPOP <a class="header-anchor" href="#rpop" aria-label="Permalink to &quot;RPOP&quot;">​</a></h3><p>移除并返回列表 key 的尾元素。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>RPOP key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; RPUSH mylist &quot;one&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSH mylist &quot;two&quot;</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSH mylist &quot;three&quot;</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPOP mylist           # 返回被弹出的元素</span></span>
<span class="line"><span>&quot;three&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE mylist 0 -1    # 列表剩下的元素</span></span>
<span class="line"><span>1) &quot;one&quot;</span></span>
<span class="line"><span>2) &quot;two&quot;</span></span></code></pre></div><h3 id="rpoplpush" tabindex="-1">RPOPLPUSH <a class="header-anchor" href="#rpoplpush" aria-label="Permalink to &quot;RPOPLPUSH&quot;">​</a></h3><p>命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：</p><p>举个例子，你有两个列表 source 和 destination ， source 列表有元素 a, b, c ， destination 列表有元素 x, y, z ，执行 RPOPLPUSH source destination 之后， source 列表包含元素 a, b ， destination 列表包含元素 c, x, y, z ，并且元素 c 会被返回给客户端。</p><p>如果 source 不存在，值 nil 被返回，并且不执行其他动作。</p><p>如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</p><p>Redis的列表经常被用作队列(queue)，用于在不同程序之间有序地交换消息(message)。一个客户端通过 LPUSH 命令将消息放入队列中，而另一个客户端通过 RPOP 或者 BRPOP 命令取出队列中等待时间最长的消息。</p><p>不幸的是，上面的队列方法是『不安全』的，因为在这个过程中，一个客户端可能在取出一个消息之后崩溃，而未处理完的消息也就因此丢失。</p><p>使用 RPOPLPUSH 命令(或者它的阻塞版本 BRPOPLPUSH )可以解决这个问题：因为它不仅返回一个消息，同时还将这个消息添加到另一个备份列表当中，如果一切正常的话，当一个客户端完成某个消息的处理之后，可以用 LREM 命令将这个消息从备份表删除。</p><p>最后，还可以添加一个客户端专门用于监视备份表，它自动地将超过一定处理时限的消息重新放入队列中去(负责处理该消息的客户端可能已经崩溃)，这样就不会丢失任何消息了。</p><p>通过使用相同的 key 作为 RPOPLPUSH 命令的两个参数，客户端可以用一个接一个地获取列表元素的方式，取得列表的所有元素，而不必像 LRANGE 命令那样一下子将所有列表元素都从服务器传送到客户端中(两种方式的总复杂度都是 O(N))。</p><p>以上的模式甚至在以下的两个情况下也能正常工作：</p><p>这个模式使得我们可以很容易实现这样一类系统：有 N 个客户端，需要连续不断地对一些元素进行处理，而且处理的过程必须尽可能地快。一个典型的例子就是服务器的监控程序：它们需要在尽可能短的时间内，并行地检查一组网站，确保它们的可访问性。</p><p>注意，使用这个模式的客户端是易于扩展(scala)且安全(reliable)的，因为就算接收到元素的客户端失败，元素还是保存在列表里面，不会丢失，等到下个迭代来临的时候，别的客户端又可以继续处理这些元素了。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>RPOPLPUSH source destination</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># source 和 destination 不同</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE alpha 0 -1         # 查看所有元素</span></span>
<span class="line"><span>1) &quot;a&quot;</span></span>
<span class="line"><span>2) &quot;b&quot;</span></span>
<span class="line"><span>3) &quot;c&quot;</span></span>
<span class="line"><span>4) &quot;d&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPOPLPUSH alpha reciver   # 执行一次 RPOPLPUSH 看看</span></span>
<span class="line"><span>&quot;d&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE alpha 0 -1</span></span>
<span class="line"><span>1) &quot;a&quot;</span></span>
<span class="line"><span>2) &quot;b&quot;</span></span>
<span class="line"><span>3) &quot;c&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE reciver 0 -1</span></span>
<span class="line"><span>1) &quot;d&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPOPLPUSH alpha reciver   # 再执行一次，证实 RPOP 和 LPUSH 的位置正确</span></span>
<span class="line"><span>&quot;c&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE alpha 0 -1</span></span>
<span class="line"><span>1) &quot;a&quot;</span></span>
<span class="line"><span>2) &quot;b&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE reciver 0 -1</span></span>
<span class="line"><span>1) &quot;c&quot;</span></span>
<span class="line"><span>2) &quot;d&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># source 和 destination 相同</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE number 0 -1</span></span>
<span class="line"><span>1) &quot;1&quot;</span></span>
<span class="line"><span>2) &quot;2&quot;</span></span>
<span class="line"><span>3) &quot;3&quot;</span></span>
<span class="line"><span>4) &quot;4&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPOPLPUSH number number</span></span>
<span class="line"><span>&quot;4&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE number 0 -1           # 4 被旋转到了表头</span></span>
<span class="line"><span>1) &quot;4&quot;</span></span>
<span class="line"><span>2) &quot;1&quot;</span></span>
<span class="line"><span>3) &quot;2&quot;</span></span>
<span class="line"><span>4) &quot;3&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPOPLPUSH number number</span></span>
<span class="line"><span>&quot;3&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE number 0 -1           # 这次是 3 被旋转到了表头</span></span>
<span class="line"><span>1) &quot;3&quot;</span></span>
<span class="line"><span>2) &quot;4&quot;</span></span>
<span class="line"><span>3) &quot;1&quot;</span></span>
<span class="line"><span>4) &quot;2&quot;</span></span></code></pre></div><h3 id="rpush" tabindex="-1">RPUSH <a class="header-anchor" href="#rpush" aria-label="Permalink to &quot;RPUSH&quot;">​</a></h3><p>将一个或多个值 value 插入到列表 key 的表尾(最右边)。</p><p>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 RPUSH mylist a b c ，得出的结果列表为 a b c ，等同于执行命令 RPUSH mylist a 、 RPUSH mylist b 、 RPUSH mylist c 。</p><p>如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。</p><p>当 key 存在但不是列表类型时，返回一个错误。</p><p>Note</p><p>在 Redis 2.4 版本以前的 RPUSH 命令，都只接受单个 value 值。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>RPUSH key value [value ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 添加单个元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSH languages c</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 添加重复元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSH languages c</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE languages 0 -1 # 列表允许重复元素</span></span>
<span class="line"><span>1) &quot;c&quot;</span></span>
<span class="line"><span>2) &quot;c&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 添加多个元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSH mylist a b c</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE mylist 0 -1</span></span>
<span class="line"><span>1) &quot;a&quot;</span></span>
<span class="line"><span>2) &quot;b&quot;</span></span>
<span class="line"><span>3) &quot;c&quot;</span></span></code></pre></div><h3 id="rpushx" tabindex="-1">RPUSHX <a class="header-anchor" href="#rpushx" aria-label="Permalink to &quot;RPUSHX&quot;">​</a></h3><p>将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。</p><p>和 RPUSH 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>RPUSHX key value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># key不存在</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LLEN greet</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSHX greet &quot;hello&quot;     # 对不存在的 key 进行 RPUSHX，PUSH 失败。</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># key 存在且是一个非空列表</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSH greet &quot;hi&quot;         # 先用 RPUSH 插入一个元素</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; RPUSHX greet &quot;hello&quot;     # greet 现在是一个列表类型，RPUSHX 操作成功。</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; LRANGE greet 0 -1</span></span>
<span class="line"><span>1) &quot;hi&quot;</span></span>
<span class="line"><span>2) &quot;hello&quot;</span></span></code></pre></div><h2 id="set-集合" tabindex="-1">Set（集合） <a class="header-anchor" href="#set-集合" aria-label="Permalink to &quot;Set（集合）&quot;">​</a></h2><h3 id="sadd" tabindex="-1">SADD <a class="header-anchor" href="#sadd" aria-label="Permalink to &quot;SADD&quot;">​</a></h3><p>将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。</p><p>假如 key 不存在，则创建一个只包含 member 元素作成员的集合。</p><p>当 key 不是集合类型时，返回一个错误。</p><p>Note</p><p>在Redis2.4版本以前， SADD 只接受单个 member 值。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SADD key member [member ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 添加单个元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SADD bbs &quot;discuz.net&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 添加重复元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SADD bbs &quot;discuz.net&quot;</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 添加多个元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SADD bbs &quot;tianya.cn&quot; &quot;groups.google.com&quot;</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS bbs</span></span>
<span class="line"><span>1) &quot;discuz.net&quot;</span></span>
<span class="line"><span>2) &quot;groups.google.com&quot;</span></span>
<span class="line"><span>3) &quot;tianya.cn&quot;</span></span></code></pre></div><h3 id="scard" tabindex="-1">SCARD <a class="header-anchor" href="#scard" aria-label="Permalink to &quot;SCARD&quot;">​</a></h3><p>返回集合 key 的基数(集合中元素的数量)。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SCARD key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SADD tool pc printer phone</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SCARD tool   # 非空集合</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DEL tool</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SCARD tool   # 空集合</span></span>
<span class="line"><span>(integer) 0</span></span></code></pre></div><h3 id="sdiff" tabindex="-1">SDIFF <a class="header-anchor" href="#sdiff" aria-label="Permalink to &quot;SDIFF&quot;">​</a></h3><p>返回一个集合的全部成员，该集合是所有给定集合之间的差集。</p><p>不存在的 key 被视为空集。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SDIFF key [key ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SMEMBERS peter&#39;s_movies</span></span>
<span class="line"><span>1) &quot;bet man&quot;</span></span>
<span class="line"><span>2) &quot;start war&quot;</span></span>
<span class="line"><span>3) &quot;2012&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS joe&#39;s_movies</span></span>
<span class="line"><span>1) &quot;hi, lady&quot;</span></span>
<span class="line"><span>2) &quot;Fast Five&quot;</span></span>
<span class="line"><span>3) &quot;2012&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SDIFF peter&#39;s_movies joe&#39;s_movies</span></span>
<span class="line"><span>1) &quot;bet man&quot;</span></span>
<span class="line"><span>2) &quot;start war&quot;</span></span></code></pre></div><h3 id="sdiffstore" tabindex="-1">SDIFFSTORE <a class="header-anchor" href="#sdiffstore" aria-label="Permalink to &quot;SDIFFSTORE&quot;">​</a></h3><p>这个命令的作用和 SDIFF 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p><p>如果 destination 集合已经存在，则将其覆盖。</p><p>destination 可以是 key 本身。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SDIFFSTORE destination key [key ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SMEMBERS joe&#39;s_movies</span></span>
<span class="line"><span>1) &quot;hi, lady&quot;</span></span>
<span class="line"><span>2) &quot;Fast Five&quot;</span></span>
<span class="line"><span>3) &quot;2012&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS peter&#39;s_movies</span></span>
<span class="line"><span>1) &quot;bet man&quot;</span></span>
<span class="line"><span>2) &quot;start war&quot;</span></span>
<span class="line"><span>3) &quot;2012&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SDIFFSTORE joe_diff_peter joe&#39;s_movies peter&#39;s_movies</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS joe_diff_peter</span></span>
<span class="line"><span>1) &quot;hi, lady&quot;</span></span>
<span class="line"><span>2) &quot;Fast Five&quot;</span></span></code></pre></div><h3 id="sinter" tabindex="-1">SINTER <a class="header-anchor" href="#sinter" aria-label="Permalink to &quot;SINTER&quot;">​</a></h3><p>返回一个集合的全部成员，该集合是所有给定集合的交集。</p><p>不存在的 key 被视为空集。</p><p>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SINTER key [key ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SMEMBERS group_1</span></span>
<span class="line"><span>1) &quot;LI LEI&quot;</span></span>
<span class="line"><span>2) &quot;TOM&quot;</span></span>
<span class="line"><span>3) &quot;JACK&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS group_2</span></span>
<span class="line"><span>1) &quot;HAN MEIMEI&quot;</span></span>
<span class="line"><span>2) &quot;JACK&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SINTER group_1 group_2</span></span>
<span class="line"><span>1) &quot;JACK&quot;</span></span></code></pre></div><h3 id="sinterstore" tabindex="-1">SINTERSTORE <a class="header-anchor" href="#sinterstore" aria-label="Permalink to &quot;SINTERSTORE&quot;">​</a></h3><p>这个命令类似于 SINTER 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p><p>如果 destination 集合已经存在，则将其覆盖。</p><p>destination 可以是 key 本身。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SINTERSTORE destination key [key ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SMEMBERS songs</span></span>
<span class="line"><span>1) &quot;good bye joe&quot;</span></span>
<span class="line"><span>2) &quot;hello,peter&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS my_songs</span></span>
<span class="line"><span>1) &quot;good bye joe&quot;</span></span>
<span class="line"><span>2) &quot;falling&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SINTERSTORE song_interset songs my_songs</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS song_interset</span></span>
<span class="line"><span>1) &quot;good bye joe&quot;</span></span></code></pre></div><h3 id="sismember" tabindex="-1">SISMEMBER <a class="header-anchor" href="#sismember" aria-label="Permalink to &quot;SISMEMBER&quot;">​</a></h3><p>判断 member 元素是否集合 key 的成员。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SISMEMBER key member</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SMEMBERS joe&#39;s_movies</span></span>
<span class="line"><span>1) &quot;hi, lady&quot;</span></span>
<span class="line"><span>2) &quot;Fast Five&quot;</span></span>
<span class="line"><span>3) &quot;2012&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SISMEMBER joe&#39;s_movies &quot;bet man&quot;</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SISMEMBER joe&#39;s_movies &quot;Fast Five&quot;</span></span>
<span class="line"><span>(integer) 1</span></span></code></pre></div><h3 id="smembers" tabindex="-1">SMEMBERS <a class="header-anchor" href="#smembers" aria-label="Permalink to &quot;SMEMBERS&quot;">​</a></h3><p>返回集合 key 中的所有成员。</p><p>不存在的 key 被视为空集合。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SMEMBERS key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># key 不存在或集合为空</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXISTS not_exists_key</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS not_exists_key</span></span>
<span class="line"><span>(empty list or set)</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 非空集合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SADD language Ruby Python Clojure</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS language</span></span>
<span class="line"><span>1) &quot;Python&quot;</span></span>
<span class="line"><span>2) &quot;Ruby&quot;</span></span>
<span class="line"><span>3) &quot;Clojure&quot;</span></span></code></pre></div><h3 id="smove" tabindex="-1">SMOVE <a class="header-anchor" href="#smove" aria-label="Permalink to &quot;SMOVE&quot;">​</a></h3><p>将 member 元素从 source 集合移动到 destination 集合。</p><p>SMOVE 是原子性操作。</p><p>如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。</p><p>当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。</p><p>当 source 或 destination 不是集合类型时，返回一个错误。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SMOVE source destination member</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SMEMBERS songs</span></span>
<span class="line"><span>1) &quot;Billie Jean&quot;</span></span>
<span class="line"><span>2) &quot;Believe Me&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS my_songs</span></span>
<span class="line"><span>(empty list or set)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMOVE songs my_songs &quot;Believe Me&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS songs</span></span>
<span class="line"><span>1) &quot;Billie Jean&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS my_songs</span></span>
<span class="line"><span>1) &quot;Believe Me&quot;</span></span></code></pre></div><h3 id="spop" tabindex="-1">SPOP <a class="header-anchor" href="#spop" aria-label="Permalink to &quot;SPOP&quot;">​</a></h3><p>移除并返回集合中的一个随机元素。</p><p>如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SPOP key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SMEMBERS db</span></span>
<span class="line"><span>1) &quot;MySQL&quot;</span></span>
<span class="line"><span>2) &quot;MongoDB&quot;</span></span>
<span class="line"><span>3) &quot;Redis&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SPOP db</span></span>
<span class="line"><span>&quot;Redis&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS db</span></span>
<span class="line"><span>1) &quot;MySQL&quot;</span></span>
<span class="line"><span>2) &quot;MongoDB&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SPOP db</span></span>
<span class="line"><span>&quot;MySQL&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS db</span></span>
<span class="line"><span>1) &quot;MongoDB&quot;</span></span></code></pre></div><h3 id="srandmember" tabindex="-1">SRANDMEMBER <a class="header-anchor" href="#srandmember" aria-label="Permalink to &quot;SRANDMEMBER&quot;">​</a></h3><p>如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。</p><p>从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：</p><p>该操作和 SPOP 相似，但 SPOP 将随机元素从集合中移除并返回，而 SRANDMEMBER 则仅仅返回随机元素，而不对集合进行任何改动。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SRANDMEMBER key [count]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 添加元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SADD fruit apple banana cherry</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 只给定 key 参数，返回一个随机元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SRANDMEMBER fruit</span></span>
<span class="line"><span>&quot;cherry&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SRANDMEMBER fruit</span></span>
<span class="line"><span>&quot;apple&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 给定 3 为 count 参数，返回 3 个随机元素</span></span>
<span class="line"><span># 每个随机元素都不相同</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SRANDMEMBER fruit 3</span></span>
<span class="line"><span>1) &quot;apple&quot;</span></span>
<span class="line"><span>2) &quot;banana&quot;</span></span>
<span class="line"><span>3) &quot;cherry&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 给定 -3 为 count 参数，返回 3 个随机元素</span></span>
<span class="line"><span># 元素可能会重复出现多次</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SRANDMEMBER fruit -3</span></span>
<span class="line"><span>1) &quot;banana&quot;</span></span>
<span class="line"><span>2) &quot;cherry&quot;</span></span>
<span class="line"><span>3) &quot;apple&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SRANDMEMBER fruit -3</span></span>
<span class="line"><span>1) &quot;apple&quot;</span></span>
<span class="line"><span>2) &quot;apple&quot;</span></span>
<span class="line"><span>3) &quot;cherry&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 如果 count 是整数，且大于等于集合基数，那么返回整个集合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SRANDMEMBER fruit 10</span></span>
<span class="line"><span>1) &quot;apple&quot;</span></span>
<span class="line"><span>2) &quot;banana&quot;</span></span>
<span class="line"><span>3) &quot;cherry&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 如果 count 是负数，且 count 的绝对值大于集合的基数</span></span>
<span class="line"><span># 那么返回的数组的长度为 count 的绝对值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SRANDMEMBER fruit -10</span></span>
<span class="line"><span>1) &quot;banana&quot;</span></span>
<span class="line"><span>2) &quot;apple&quot;</span></span>
<span class="line"><span>3) &quot;banana&quot;</span></span>
<span class="line"><span>4) &quot;cherry&quot;</span></span>
<span class="line"><span>5) &quot;apple&quot;</span></span>
<span class="line"><span>6) &quot;apple&quot;</span></span>
<span class="line"><span>7) &quot;cherry&quot;</span></span>
<span class="line"><span>8) &quot;apple&quot;</span></span>
<span class="line"><span>9) &quot;apple&quot;</span></span>
<span class="line"><span>10) &quot;banana&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># SRANDMEMBER 并不会修改集合内容</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS fruit</span></span>
<span class="line"><span>1) &quot;apple&quot;</span></span>
<span class="line"><span>2) &quot;cherry&quot;</span></span>
<span class="line"><span>3) &quot;banana&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 集合为空时返回 nil 或者空数组</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SRANDMEMBER not-exists</span></span>
<span class="line"><span>(nil)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SRANDMEMBER not-eixsts 10</span></span>
<span class="line"><span>(empty list or set)</span></span></code></pre></div><h3 id="srem" tabindex="-1">SREM <a class="header-anchor" href="#srem" aria-label="Permalink to &quot;SREM&quot;">​</a></h3><p>移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。</p><p>当 key 不是集合类型，返回一个错误。</p><p>Note</p><p>在 Redis 2.4 版本以前， SREM 只接受单个 member 值。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SREM key member [member ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 测试数据</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS languages</span></span>
<span class="line"><span>1) &quot;c&quot;</span></span>
<span class="line"><span>2) &quot;lisp&quot;</span></span>
<span class="line"><span>3) &quot;python&quot;</span></span>
<span class="line"><span>4) &quot;ruby&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 移除单个元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SREM languages ruby</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 移除不存在元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SREM languages non-exists-language</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 移除多个元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SREM languages lisp python c</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS languages</span></span>
<span class="line"><span>(empty list or set)</span></span></code></pre></div><h3 id="sunion" tabindex="-1">SUNION <a class="header-anchor" href="#sunion" aria-label="Permalink to &quot;SUNION&quot;">​</a></h3><p>返回一个集合的全部成员，该集合是所有给定集合的并集。</p><p>不存在的 key 被视为空集。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SUNION key [key ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SMEMBERS songs</span></span>
<span class="line"><span>1) &quot;Billie Jean&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS my_songs</span></span>
<span class="line"><span>1) &quot;Believe Me&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SUNION songs my_songs</span></span>
<span class="line"><span>1) &quot;Billie Jean&quot;</span></span>
<span class="line"><span>2) &quot;Believe Me&quot;</span></span></code></pre></div><h3 id="sunionstore" tabindex="-1">SUNIONSTORE <a class="header-anchor" href="#sunionstore" aria-label="Permalink to &quot;SUNIONSTORE&quot;">​</a></h3><p>这个命令类似于 SUNION 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p><p>如果 destination 已经存在，则将其覆盖。</p><p>destination 可以是 key 本身。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SUNIONSTORE destination key [key ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SMEMBERS NoSQL</span></span>
<span class="line"><span>1) &quot;MongoDB&quot;</span></span>
<span class="line"><span>2) &quot;Redis&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS SQL</span></span>
<span class="line"><span>1) &quot;sqlite&quot;</span></span>
<span class="line"><span>2) &quot;MySQL&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SUNIONSTORE db NoSQL SQL</span></span>
<span class="line"><span>(integer) 4</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SMEMBERS db</span></span>
<span class="line"><span>1) &quot;MySQL&quot;</span></span>
<span class="line"><span>2) &quot;sqlite&quot;</span></span>
<span class="line"><span>3) &quot;MongoDB&quot;</span></span>
<span class="line"><span>4) &quot;Redis&quot;</span></span></code></pre></div><h3 id="sscan" tabindex="-1">SSCAN <a class="header-anchor" href="#sscan" aria-label="Permalink to &quot;SSCAN&quot;">​</a></h3><h2 id="sortedset-有序集合" tabindex="-1">SortedSet（有序集合） <a class="header-anchor" href="#sortedset-有序集合" aria-label="Permalink to &quot;SortedSet（有序集合）&quot;">​</a></h2><h3 id="zadd" tabindex="-1">ZADD <a class="header-anchor" href="#zadd" aria-label="Permalink to &quot;ZADD&quot;">​</a></h3><p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p><p>如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。</p><p>score 值可以是整数值或双精度浮点数。</p><p>如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</p><p>当 key 存在但不是有序集类型时，返回一个错误。</p><p>对有序集的更多介绍请参见 sorted set 。</p><p>Note</p><p>在 Redis 2.4 版本以前， ZADD 每次只能添加一个元素。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZADD key score member [[score member] [score member] ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 添加单个元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZADD page_rank 10 google.com</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 添加多个元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZADD page_rank 9 baidu.com 8 bing.com</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span></span>
<span class="line"><span>1) &quot;bing.com&quot;</span></span>
<span class="line"><span>2) &quot;8&quot;</span></span>
<span class="line"><span>3) &quot;baidu.com&quot;</span></span>
<span class="line"><span>4) &quot;9&quot;</span></span>
<span class="line"><span>5) &quot;google.com&quot;</span></span>
<span class="line"><span>6) &quot;10&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 添加已存在元素，且 score 值不变</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZADD page_rank 10 google.com</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # 没有改变</span></span>
<span class="line"><span>1) &quot;bing.com&quot;</span></span>
<span class="line"><span>2) &quot;8&quot;</span></span>
<span class="line"><span>3) &quot;baidu.com&quot;</span></span>
<span class="line"><span>4) &quot;9&quot;</span></span>
<span class="line"><span>5) &quot;google.com&quot;</span></span>
<span class="line"><span>6) &quot;10&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 添加已存在元素，但是改变 score 值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZADD page_rank 6 bing.com</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # bing.com 元素的 score 值被改变</span></span>
<span class="line"><span>1) &quot;bing.com&quot;</span></span>
<span class="line"><span>2) &quot;6&quot;</span></span>
<span class="line"><span>3) &quot;baidu.com&quot;</span></span>
<span class="line"><span>4) &quot;9&quot;</span></span>
<span class="line"><span>5) &quot;google.com&quot;</span></span>
<span class="line"><span>6) &quot;10&quot;</span></span></code></pre></div><h3 id="zcard" tabindex="-1">ZCARD <a class="header-anchor" href="#zcard" aria-label="Permalink to &quot;ZCARD&quot;">​</a></h3><p>返回有序集 key 的基数。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZCARD key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis &gt; ZADD salary 2000 tom    # 添加一个成员</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis &gt; ZCARD salary</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis &gt; ZADD salary 5000 jack   # 再添加一个成员</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis &gt; ZCARD salary</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis &gt; EXISTS non_exists_key   # 对不存在的 key 进行 ZCARD 操作</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis &gt; ZCARD non_exists_key</span></span>
<span class="line"><span>(integer) 0</span></span></code></pre></div><h3 id="zcount" tabindex="-1">ZCOUNT <a class="header-anchor" href="#zcount" aria-label="Permalink to &quot;ZCOUNT&quot;">​</a></h3><p>返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</p><p>关于参数 min 和 max 的详细使用方法，请参考 ZRANGEBYSCORE 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZCOUNT key min max</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 测试数据</span></span>
<span class="line"><span>1) &quot;jack&quot;</span></span>
<span class="line"><span>2) &quot;2000&quot;</span></span>
<span class="line"><span>3) &quot;peter&quot;</span></span>
<span class="line"><span>4) &quot;3500&quot;</span></span>
<span class="line"><span>5) &quot;tom&quot;</span></span>
<span class="line"><span>6) &quot;5000&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZCOUNT salary 2000 5000          # 计算薪水在 2000-5000 之间的人数</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZCOUNT salary 3000 5000          # 计算薪水在 3000-5000 之间的人数</span></span>
<span class="line"><span>(integer) 2</span></span></code></pre></div><h3 id="zincrby" tabindex="-1">ZINCRBY <a class="header-anchor" href="#zincrby" aria-label="Permalink to &quot;ZINCRBY&quot;">​</a></h3><p>为有序集 key 的成员 member 的 score 值加上增量 increment 。</p><p>可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。</p><p>当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。</p><p>当 key 不是有序集类型时，返回一个错误。</p><p>score 值可以是整数值或双精度浮点数。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZINCRBY key increment member</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; ZSCORE salary tom</span></span>
<span class="line"><span>&quot;2000&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZINCRBY salary 2000 tom   # tom 加薪啦！</span></span>
<span class="line"><span>&quot;4000&quot;</span></span></code></pre></div><h3 id="zrange" tabindex="-1">ZRANGE <a class="header-anchor" href="#zrange" aria-label="Permalink to &quot;ZRANGE&quot;">​</a></h3><p>返回有序集 key 中，指定区间内的成员。</p><p>其中成员的位置按 score 值递增(从小到大)来排序。</p><p>具有相同 score 值的成员按字典序(lexicographical order )来排列。</p><p>如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZRANGE key start stop [WITHSCORES]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis &gt; ZRANGE salary 0 -1 WITHSCORES             # 显示整个有序集成员</span></span>
<span class="line"><span>1) &quot;jack&quot;</span></span>
<span class="line"><span>2) &quot;3500&quot;</span></span>
<span class="line"><span>3) &quot;tom&quot;</span></span>
<span class="line"><span>4) &quot;5000&quot;</span></span>
<span class="line"><span>5) &quot;boss&quot;</span></span>
<span class="line"><span>6) &quot;10086&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis &gt; ZRANGE salary 1 2 WITHSCORES              # 显示有序集下标区间 1 至 2 的成员</span></span>
<span class="line"><span>1) &quot;tom&quot;</span></span>
<span class="line"><span>2) &quot;5000&quot;</span></span>
<span class="line"><span>3) &quot;boss&quot;</span></span>
<span class="line"><span>4) &quot;10086&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis &gt; ZRANGE salary 0 200000 WITHSCORES         # 测试 end 下标超出最大下标时的情况</span></span>
<span class="line"><span>1) &quot;jack&quot;</span></span>
<span class="line"><span>2) &quot;3500&quot;</span></span>
<span class="line"><span>3) &quot;tom&quot;</span></span>
<span class="line"><span>4) &quot;5000&quot;</span></span>
<span class="line"><span>5) &quot;boss&quot;</span></span>
<span class="line"><span>6) &quot;10086&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis &gt; ZRANGE salary 200000 3000000 WITHSCORES   # 测试当给定区间不存在于有序集时的情况</span></span>
<span class="line"><span>(empty list or set)</span></span></code></pre></div><h3 id="zrangebyscore" tabindex="-1">ZRANGEBYSCORE <a class="header-anchor" href="#zrangebyscore" aria-label="Permalink to &quot;ZRANGEBYSCORE&quot;">​</a></h3><p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</p><p>具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。</p><p>可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。</p><p>区间及无限</p><p>min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。</p><p>默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</p><p>举个例子：</p><p>返回所有符合条件 1 &lt; score &lt;= 5 的成员，而</p><p>则返回所有符合条件 5 &lt; score &lt; 10 的成员。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZRANGEBYSCORE zset (1 5</span></span></code></pre></div><h3 id="zrank" tabindex="-1">ZRANK <a class="header-anchor" href="#zrank" aria-label="Permalink to &quot;ZRANK&quot;">​</a></h3><p>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。</p><p>排名以 0 为底，也就是说， score 值最小的成员排名为 0 。</p><p>使用 ZREVRANK 命令可以获得成员按 score 值递减(从大到小)排列的排名。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZRANK key member</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; ZRANGE salary 0 -1 WITHSCORES        # 显示所有成员及其 score 值</span></span>
<span class="line"><span>1) &quot;peter&quot;</span></span>
<span class="line"><span>2) &quot;3500&quot;</span></span>
<span class="line"><span>3) &quot;tom&quot;</span></span>
<span class="line"><span>4) &quot;4000&quot;</span></span>
<span class="line"><span>5) &quot;jack&quot;</span></span>
<span class="line"><span>6) &quot;5000&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZRANK salary tom                     # 显示 tom 的薪水排名，第二</span></span>
<span class="line"><span>(integer) 1</span></span></code></pre></div><h3 id="zrem" tabindex="-1">ZREM <a class="header-anchor" href="#zrem" aria-label="Permalink to &quot;ZREM&quot;">​</a></h3><p>移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</p><p>当 key 存在但不是有序集类型时，返回一个错误。</p><p>Note</p><p>在 Redis 2.4 版本以前， ZREM 每次只能删除一个元素。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZREM key member [member ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 测试数据</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span></span>
<span class="line"><span>1) &quot;bing.com&quot;</span></span>
<span class="line"><span>2) &quot;8&quot;</span></span>
<span class="line"><span>3) &quot;baidu.com&quot;</span></span>
<span class="line"><span>4) &quot;9&quot;</span></span>
<span class="line"><span>5) &quot;google.com&quot;</span></span>
<span class="line"><span>6) &quot;10&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 移除单个元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZREM page_rank google.com</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span></span>
<span class="line"><span>1) &quot;bing.com&quot;</span></span>
<span class="line"><span>2) &quot;8&quot;</span></span>
<span class="line"><span>3) &quot;baidu.com&quot;</span></span>
<span class="line"><span>4) &quot;9&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 移除多个元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZREM page_rank baidu.com bing.com</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span></span>
<span class="line"><span>(empty list or set)</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 移除不存在元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZREM page_rank non-exists-element</span></span>
<span class="line"><span>(integer) 0</span></span></code></pre></div><h3 id="zremrangebyrank" tabindex="-1">ZREMRANGEBYRANK <a class="header-anchor" href="#zremrangebyrank" aria-label="Permalink to &quot;ZREMRANGEBYRANK&quot;">​</a></h3><p>移除有序集 key 中，指定排名(rank)区间内的所有成员。</p><p>区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZREMRANGEBYRANK key start stop</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; ZADD salary 2000 jack</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis&gt; ZADD salary 5000 tom</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis&gt; ZADD salary 3500 peter</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZREMRANGEBYRANK salary 0 1       # 移除下标 0 至 1 区间内的成员</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 有序集只剩下一个成员</span></span>
<span class="line"><span>1) &quot;tom&quot;</span></span>
<span class="line"><span>2) &quot;5000&quot;</span></span></code></pre></div><h3 id="zremrangebyscore" tabindex="-1">ZREMRANGEBYSCORE <a class="header-anchor" href="#zremrangebyscore" aria-label="Permalink to &quot;ZREMRANGEBYSCORE&quot;">​</a></h3><p>移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。</p><p>自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 ZRANGEBYSCORE 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZREMRANGEBYSCORE key min max</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 显示有序集内所有成员及其 score 值</span></span>
<span class="line"><span>1) &quot;tom&quot;</span></span>
<span class="line"><span>2) &quot;2000&quot;</span></span>
<span class="line"><span>3) &quot;peter&quot;</span></span>
<span class="line"><span>4) &quot;3500&quot;</span></span>
<span class="line"><span>5) &quot;jack&quot;</span></span>
<span class="line"><span>6) &quot;5000&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZREMRANGEBYSCORE salary 1500 3500      # 移除所有薪水在 1500 到 3500 内的员工</span></span>
<span class="line"><span>(integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 剩下的有序集成员</span></span>
<span class="line"><span>1) &quot;jack&quot;</span></span>
<span class="line"><span>2) &quot;5000&quot;</span></span></code></pre></div><h3 id="zrevrange" tabindex="-1">ZREVRANGE <a class="header-anchor" href="#zrevrange" aria-label="Permalink to &quot;ZREVRANGE&quot;">​</a></h3><p>返回有序集 key 中，指定区间内的成员。</p><p>除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE 命令一样。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZREVRANGE key start stop [WITHSCORES]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; ZRANGE salary 0 -1 WITHSCORES        # 递增排列</span></span>
<span class="line"><span>1) &quot;peter&quot;</span></span>
<span class="line"><span>2) &quot;3500&quot;</span></span>
<span class="line"><span>3) &quot;tom&quot;</span></span>
<span class="line"><span>4) &quot;4000&quot;</span></span>
<span class="line"><span>5) &quot;jack&quot;</span></span>
<span class="line"><span>6) &quot;5000&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZREVRANGE salary 0 -1 WITHSCORES     # 递减排列</span></span>
<span class="line"><span>1) &quot;jack&quot;</span></span>
<span class="line"><span>2) &quot;5000&quot;</span></span>
<span class="line"><span>3) &quot;tom&quot;</span></span>
<span class="line"><span>4) &quot;4000&quot;</span></span>
<span class="line"><span>5) &quot;peter&quot;</span></span>
<span class="line"><span>6) &quot;3500&quot;</span></span></code></pre></div><h3 id="zrevrangebyscore" tabindex="-1">ZREVRANGEBYSCORE <a class="header-anchor" href="#zrevrangebyscore" aria-label="Permalink to &quot;ZREVRANGEBYSCORE&quot;">​</a></h3><p>返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。</p><p>具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。</p><p>除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE 命令一样。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis &gt; ZADD salary 10086 jack</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis &gt; ZADD salary 5000 tom</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis &gt; ZADD salary 7500 peter</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis &gt; ZADD salary 3500 joe</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis &gt; ZREVRANGEBYSCORE salary +inf -inf   # 逆序排列所有成员</span></span>
<span class="line"><span>1) &quot;jack&quot;</span></span>
<span class="line"><span>2) &quot;peter&quot;</span></span>
<span class="line"><span>3) &quot;tom&quot;</span></span>
<span class="line"><span>4) &quot;joe&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis &gt; ZREVRANGEBYSCORE salary 10000 2000  # 逆序排列薪水介于 10000 和 2000 之间的成员</span></span>
<span class="line"><span>1) &quot;peter&quot;</span></span>
<span class="line"><span>2) &quot;tom&quot;</span></span>
<span class="line"><span>3) &quot;joe&quot;</span></span></code></pre></div><h3 id="zrevrank" tabindex="-1">ZREVRANK <a class="header-anchor" href="#zrevrank" aria-label="Permalink to &quot;ZREVRANK&quot;">​</a></h3><p>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。</p><p>排名以 0 为底，也就是说， score 值最大的成员排名为 0 。</p><p>使用 ZRANK 命令可以获得成员按 score 值递增(从小到大)排列的排名。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZREVRANK key member</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis 127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES     # 测试数据</span></span>
<span class="line"><span>1) &quot;jack&quot;</span></span>
<span class="line"><span>2) &quot;2000&quot;</span></span>
<span class="line"><span>3) &quot;peter&quot;</span></span>
<span class="line"><span>4) &quot;3500&quot;</span></span>
<span class="line"><span>5) &quot;tom&quot;</span></span>
<span class="line"><span>6) &quot;5000&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZREVRANK salary peter     # peter 的工资排第二</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZREVRANK salary tom       # tom 的工资最高</span></span>
<span class="line"><span>(integer) 0</span></span></code></pre></div><h3 id="zscore" tabindex="-1">ZSCORE <a class="header-anchor" href="#zscore" aria-label="Permalink to &quot;ZSCORE&quot;">​</a></h3><p>返回有序集 key 中，成员 member 的 score 值。</p><p>如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZSCORE key member</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 测试数据</span></span>
<span class="line"><span>1) &quot;tom&quot;</span></span>
<span class="line"><span>2) &quot;2000&quot;</span></span>
<span class="line"><span>3) &quot;peter&quot;</span></span>
<span class="line"><span>4) &quot;3500&quot;</span></span>
<span class="line"><span>5) &quot;jack&quot;</span></span>
<span class="line"><span>6) &quot;5000&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZSCORE salary peter              # 注意返回值是字符串</span></span>
<span class="line"><span>&quot;3500&quot;</span></span></code></pre></div><h3 id="zunionstore" tabindex="-1">ZUNIONSTORE <a class="header-anchor" href="#zunionstore" aria-label="Permalink to &quot;ZUNIONSTORE&quot;">​</a></h3><p>计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。</p><p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。</p><p>WEIGHTS</p><p>使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。</p><p>如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。</p><p>AGGREGATE</p><p>使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。</p><p>默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; ZRANGE programmer 0 -1 WITHSCORES</span></span>
<span class="line"><span>1) &quot;peter&quot;</span></span>
<span class="line"><span>2) &quot;2000&quot;</span></span>
<span class="line"><span>3) &quot;jack&quot;</span></span>
<span class="line"><span>4) &quot;3500&quot;</span></span>
<span class="line"><span>5) &quot;tom&quot;</span></span>
<span class="line"><span>6) &quot;5000&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZRANGE manager 0 -1 WITHSCORES</span></span>
<span class="line"><span>1) &quot;herry&quot;</span></span>
<span class="line"><span>2) &quot;2000&quot;</span></span>
<span class="line"><span>3) &quot;mary&quot;</span></span>
<span class="line"><span>4) &quot;3500&quot;</span></span>
<span class="line"><span>5) &quot;bob&quot;</span></span>
<span class="line"><span>6) &quot;4000&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZUNIONSTORE salary 2 programmer manager WEIGHTS 1 3   # 公司决定加薪。。。除了程序员。。。</span></span>
<span class="line"><span>(integer) 6</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ZRANGE salary 0 -1 WITHSCORES</span></span>
<span class="line"><span>1) &quot;peter&quot;</span></span>
<span class="line"><span>2) &quot;2000&quot;</span></span>
<span class="line"><span>3) &quot;jack&quot;</span></span>
<span class="line"><span>4) &quot;3500&quot;</span></span>
<span class="line"><span>5) &quot;tom&quot;</span></span>
<span class="line"><span>6) &quot;5000&quot;</span></span>
<span class="line"><span>7) &quot;herry&quot;</span></span>
<span class="line"><span>8) &quot;6000&quot;</span></span>
<span class="line"><span>9) &quot;mary&quot;</span></span>
<span class="line"><span>10) &quot;10500&quot;</span></span>
<span class="line"><span>11) &quot;bob&quot;</span></span>
<span class="line"><span>12) &quot;12000&quot;</span></span></code></pre></div><h3 id="zinterstore" tabindex="-1">ZINTERSTORE <a class="header-anchor" href="#zinterstore" aria-label="Permalink to &quot;ZINTERSTORE&quot;">​</a></h3><p>计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。</p><p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.</p><p>关于 WEIGHTS 和 AGGREGATE 选项的描述，参见 ZUNIONSTORE 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis &gt; ZADD mid_test 70 &quot;Li Lei&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis &gt; ZADD mid_test 70 &quot;Han Meimei&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis &gt; ZADD mid_test 99.5 &quot;Tom&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis &gt; ZADD fin_test 88 &quot;Li Lei&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis &gt; ZADD fin_test 75 &quot;Han Meimei&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis &gt; ZADD fin_test 99.5 &quot;Tom&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis &gt; ZINTERSTORE sum_point 2 mid_test fin_test</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis &gt; ZRANGE sum_point 0 -1 WITHSCORES     # 显示有序集内所有成员及其 score 值</span></span>
<span class="line"><span>1) &quot;Han Meimei&quot;</span></span>
<span class="line"><span>2) &quot;145&quot;</span></span>
<span class="line"><span>3) &quot;Li Lei&quot;</span></span>
<span class="line"><span>4) &quot;158&quot;</span></span>
<span class="line"><span>5) &quot;Tom&quot;</span></span>
<span class="line"><span>6) &quot;199&quot;</span></span></code></pre></div><h3 id="zscan" tabindex="-1">ZSCAN <a class="header-anchor" href="#zscan" aria-label="Permalink to &quot;ZSCAN&quot;">​</a></h3><h2 id="pub-sub-发布-订阅" tabindex="-1">Pub/Sub（发布/订阅） <a class="header-anchor" href="#pub-sub-发布-订阅" aria-label="Permalink to &quot;Pub/Sub（发布/订阅）&quot;">​</a></h2><h3 id="psubscribe" tabindex="-1">PSUBSCRIBE <a class="header-anchor" href="#psubscribe" aria-label="Permalink to &quot;PSUBSCRIBE&quot;">​</a></h3><p>订阅一个或多个符合给定模式的频道。</p><p>每个模式以 * 作为匹配符，比如 it* 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)， news.* 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PSUBSCRIBE pattern [pattern ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 订阅 news.* 和 tweet.* 两个模式</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 第 1 - 6 行是执行 psubscribe 之后的反馈信息</span></span>
<span class="line"><span># 第 7 - 10 才是接收到的第一条信息</span></span>
<span class="line"><span># 第 11 - 14 是第二条</span></span>
<span class="line"><span># 以此类推。。。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; psubscribe news.* tweet.*</span></span>
<span class="line"><span>Reading messages... (press Ctrl-C to quit)</span></span>
<span class="line"><span>1) &quot;psubscribe&quot;                  # 返回值的类型：显示订阅成功</span></span>
<span class="line"><span>2) &quot;news.*&quot;                      # 订阅的模式</span></span>
<span class="line"><span>3) (integer) 1                   # 目前已订阅的模式的数量</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1) &quot;psubscribe&quot;</span></span>
<span class="line"><span>2) &quot;tweet.*&quot;</span></span>
<span class="line"><span>3) (integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1) &quot;pmessage&quot;                    # 返回值的类型：信息</span></span>
<span class="line"><span>2) &quot;news.*&quot;                      # 信息匹配的模式</span></span>
<span class="line"><span>3) &quot;news.it&quot;                     # 信息本身的目标频道</span></span>
<span class="line"><span>4) &quot;Google buy Motorola&quot;         # 信息的内容</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1) &quot;pmessage&quot;</span></span>
<span class="line"><span>2) &quot;tweet.*&quot;</span></span>
<span class="line"><span>3) &quot;tweet.huangz&quot;</span></span>
<span class="line"><span>4) &quot;hello&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1) &quot;pmessage&quot;</span></span>
<span class="line"><span>2) &quot;tweet.*&quot;</span></span>
<span class="line"><span>3) &quot;tweet.joe&quot;</span></span>
<span class="line"><span>4) &quot;@huangz morning&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1) &quot;pmessage&quot;</span></span>
<span class="line"><span>2) &quot;news.*&quot;</span></span>
<span class="line"><span>3) &quot;news.life&quot;</span></span>
<span class="line"><span>4) &quot;An apple a day, keep doctors away&quot;</span></span></code></pre></div><h3 id="publish" tabindex="-1">PUBLISH <a class="header-anchor" href="#publish" aria-label="Permalink to &quot;PUBLISH&quot;">​</a></h3><p>将信息 message 发送到指定的频道 channel 。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PUBLISH channel message</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 对没有订阅者的频道发送信息</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; publish bad_channel &quot;can any body hear me?&quot;</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 向有一个订阅者的频道发送信息</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; publish msg &quot;good morning&quot;</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 向有多个订阅者的频道发送信息</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; publish chat_room &quot;hello~ everyone&quot;</span></span>
<span class="line"><span>(integer) 3</span></span></code></pre></div><h3 id="pubsub" tabindex="-1">PUBSUB <a class="header-anchor" href="#pubsub" aria-label="Permalink to &quot;PUBSUB&quot;">​</a></h3><p>PUBSUB 是一个查看订阅与发布系统状态的内省命令， 它由数个不同格式的子命令组成， 以下将分别对这些子命令进行介绍。</p><p>可用版本： &gt;= 2.8.0</p><p>列出当前的活跃频道。</p><p>活跃频道指的是那些至少有一个订阅者的频道， 订阅模式的客户端不计算在内。</p><p>pattern 参数是可选的：</p><p>复杂度： O(N) ， N 为活跃频道的数量（对于长度较短的频道和模式来说，将进行模式匹配的复杂度视为常数）。</p><p>返回值： 一个由活跃频道组成的列表。</p><p>返回给定频道的订阅者数量， 订阅模式的客户端不计算在内。</p><p>复杂度： O(N) ， N 为给定频道的数量。</p><p>返回值： 一个多条批量回复（Multi-bulk reply），回复中包含给定的频道，以及频道的订阅者数量。 格式为：频道 channel-1 ， channel-1 的订阅者数量，频道 channel-2 ， channel-2 的订阅者数量，诸如此类。 回复中频道的排列顺序和执行命令时给定频道的排列顺序一致。 不给定任何频道而直接调用这个命令也是可以的， 在这种情况下， 命令只返回一个空列表。</p><p>返回订阅模式的数量。</p><p>注意， 这个命令返回的不是订阅模式的客户端的数量， 而是客户端订阅的所有模式的数量总和。</p><p>复杂度： O(1) 。</p><p>返回值： 一个整数回复（Integer reply）。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PUBSUB &lt;subcommand&gt; [argument [argument ...]]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># client-1 订阅 news.it 和 news.sport 两个频道</span></span>
<span class="line"><span></span></span>
<span class="line"><span>client-1&gt; SUBSCRIBE news.it news.sport</span></span>
<span class="line"><span>Reading messages... (press Ctrl-C to quit)</span></span>
<span class="line"><span>1) &quot;subscribe&quot;</span></span>
<span class="line"><span>2) &quot;news.it&quot;</span></span>
<span class="line"><span>3) (integer) 1</span></span>
<span class="line"><span>1) &quot;subscribe&quot;</span></span>
<span class="line"><span>2) &quot;news.sport&quot;</span></span>
<span class="line"><span>3) (integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span># client-2 订阅 news.it 和 news.internet 两个频道</span></span>
<span class="line"><span></span></span>
<span class="line"><span>client-2&gt; SUBSCRIBE news.it news.internet</span></span>
<span class="line"><span>Reading messages... (press Ctrl-C to quit)</span></span>
<span class="line"><span>1) &quot;subscribe&quot;</span></span>
<span class="line"><span>2) &quot;news.it&quot;</span></span>
<span class="line"><span>3) (integer) 1</span></span>
<span class="line"><span>1) &quot;subscribe&quot;</span></span>
<span class="line"><span>2) &quot;news.internet&quot;</span></span>
<span class="line"><span>3) (integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 首先， client-3 打印所有活跃频道</span></span>
<span class="line"><span># 注意，即使一个频道有多个订阅者，它也只输出一次，比如 news.it</span></span>
<span class="line"><span></span></span>
<span class="line"><span>client-3&gt; PUBSUB CHANNELS</span></span>
<span class="line"><span>1) &quot;news.sport&quot;</span></span>
<span class="line"><span>2) &quot;news.internet&quot;</span></span>
<span class="line"><span>3) &quot;news.it&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 接下来， client-3 打印那些与模式 news.i* 相匹配的活跃频道</span></span>
<span class="line"><span># 因为 news.sport 不匹配 news.i* ，所以它没有被打印</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PUBSUB CHANNELS news.i*</span></span>
<span class="line"><span>1) &quot;news.internet&quot;</span></span>
<span class="line"><span>2) &quot;news.it&quot;</span></span></code></pre></div><h3 id="punsubscribe" tabindex="-1">PUNSUBSCRIBE <a class="header-anchor" href="#punsubscribe" aria-label="Permalink to &quot;PUNSUBSCRIBE&quot;">​</a></h3><h3 id="subscribe" tabindex="-1">SUBSCRIBE <a class="header-anchor" href="#subscribe" aria-label="Permalink to &quot;SUBSCRIBE&quot;">​</a></h3><p>订阅给定的一个或多个频道的信息。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SUBSCRIBE channel [channel ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 订阅 msg 和 chat_room 两个频道</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 1 - 6 行是执行 subscribe 之后的反馈信息</span></span>
<span class="line"><span># 第 7 - 9 行才是接收到的第一条信息</span></span>
<span class="line"><span># 第 10 - 12 行是第二条</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; subscribe msg chat_room</span></span>
<span class="line"><span>Reading messages... (press Ctrl-C to quit)</span></span>
<span class="line"><span>1) &quot;subscribe&quot;       # 返回值的类型：显示订阅成功</span></span>
<span class="line"><span>2) &quot;msg&quot;             # 订阅的频道名字</span></span>
<span class="line"><span>3) (integer) 1       # 目前已订阅的频道数量</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1) &quot;subscribe&quot;</span></span>
<span class="line"><span>2) &quot;chat_room&quot;</span></span>
<span class="line"><span>3) (integer) 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1) &quot;message&quot;         # 返回值的类型：信息</span></span>
<span class="line"><span>2) &quot;msg&quot;             # 来源(从那个频道发送过来)</span></span>
<span class="line"><span>3) &quot;hello moto&quot;      # 信息内容</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1) &quot;message&quot;</span></span>
<span class="line"><span>2) &quot;chat_room&quot;</span></span>
<span class="line"><span>3) &quot;testing...haha&quot;</span></span></code></pre></div><h3 id="unsubscribe" tabindex="-1">UNSUBSCRIBE <a class="header-anchor" href="#unsubscribe" aria-label="Permalink to &quot;UNSUBSCRIBE&quot;">​</a></h3><h2 id="transaction-事务" tabindex="-1">Transaction（事务） <a class="header-anchor" href="#transaction-事务" aria-label="Permalink to &quot;Transaction（事务）&quot;">​</a></h2><h3 id="discard" tabindex="-1">DISCARD <a class="header-anchor" href="#discard" aria-label="Permalink to &quot;DISCARD&quot;">​</a></h3><p>取消事务，放弃执行事务块内的所有命令。</p><p>如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DISCARD</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; MULTI</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PING</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET greeting &quot;hello&quot;</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DISCARD</span></span>
<span class="line"><span>OK</span></span></code></pre></div><h3 id="exec" tabindex="-1">EXEC <a class="header-anchor" href="#exec" aria-label="Permalink to &quot;EXEC&quot;">​</a></h3><p>执行所有事务块内的命令。</p><p>假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXEC</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 事务被成功执行</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; MULTI</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCR user_id</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCR user_id</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCR user_id</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PING</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXEC</span></span>
<span class="line"><span>1) (integer) 1</span></span>
<span class="line"><span>2) (integer) 2</span></span>
<span class="line"><span>3) (integer) 3</span></span>
<span class="line"><span>4) PONG</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 监视 key ，且事务成功执行</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; WATCH lock lock_times</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; MULTI</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET lock &quot;huangz&quot;</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCR lock_times</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXEC</span></span>
<span class="line"><span>1) OK</span></span>
<span class="line"><span>2) (integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 监视 key ，且事务被打断</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; WATCH lock lock_times</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; MULTI</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET lock &quot;joe&quot;        # 就在这时，另一个客户端修改了 lock_times 的值</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCR lock_times</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXEC                  # 因为 lock_times 被修改， joe 的事务执行失败</span></span>
<span class="line"><span>(nil)</span></span></code></pre></div><h3 id="multi" tabindex="-1">MULTI <a class="header-anchor" href="#multi" aria-label="Permalink to &quot;MULTI&quot;">​</a></h3><p>标记一个事务块的开始。</p><p>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MULTI</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; MULTI            # 标记事务开始</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCR user_id     # 多条命令按顺序入队</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCR user_id</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; INCR user_id</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PING</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EXEC             # 执行</span></span>
<span class="line"><span>1) (integer) 1</span></span>
<span class="line"><span>2) (integer) 2</span></span>
<span class="line"><span>3) (integer) 3</span></span>
<span class="line"><span>4) PONG</span></span></code></pre></div><h3 id="unwatch" tabindex="-1">UNWATCH <a class="header-anchor" href="#unwatch" aria-label="Permalink to &quot;UNWATCH&quot;">​</a></h3><p>取消 WATCH 命令对所有 key 的监视。</p><p>如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。</p><p>因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UNWATCH</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; WATCH lock lock_times</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; UNWATCH</span></span>
<span class="line"><span>OK</span></span></code></pre></div><h3 id="watch" tabindex="-1">WATCH <a class="header-anchor" href="#watch" aria-label="Permalink to &quot;WATCH&quot;">​</a></h3><p>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WATCH key [key ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; WATCH lock lock_times</span></span>
<span class="line"><span>OK</span></span></code></pre></div><h2 id="script-脚本" tabindex="-1">Script（脚本） <a class="header-anchor" href="#script-脚本" aria-label="Permalink to &quot;Script（脚本）&quot;">​</a></h2><h3 id="eval" tabindex="-1">EVAL <a class="header-anchor" href="#eval" aria-label="Permalink to &quot;EVAL&quot;">​</a></h3><p>从 Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用 EVAL 命令对 Lua 脚本进行求值。</p><p>script 参数是一段 Lua 5.1 脚本程序，它会被运行在 Redis 服务器上下文中，这段脚本不必(也不应该)定义为一个 Lua 函数。</p><p>numkeys 参数用于指定键名参数的个数。</p><p>键名参数 key [key ...] 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。</p><p>在命令的最后，那些不是键名参数的附加参数 arg [arg ...] ，可以在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</p><p>上面这几段长长的说明可以用一个简单的例子来概括：</p><p>其中 &quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot; 是被求值的 Lua 脚本，数字 2 指定了键名参数的数量， key1 和 key2 是键名参数，分别使用 KEYS[1] 和 KEYS[2] 访问，而最后的 first 和 second 则是附加参数，可以通过 ARGV[1] 和 ARGV[2] 访问它们。</p><p>在 Lua 脚本中，可以使用两个不同函数来执行 Redis 命令，它们分别是：</p><p>这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误，在后面的『错误处理』部分会讲到这一点。</p><p>redis.call() 和 redis.pcall() 两个函数的参数可以是任何格式良好(well formed)的 Redis 命令：</p><p>需要注意的是，上面这段脚本的确实现了将键 foo 的值设为 bar 的目的，但是，它违反了 EVAL 命令的语义，因为脚本里使用的所有键都应该由 KEYS 数组来传递，就像这样：</p><p>要求使用正确的形式来传递键(key)是有原因的，因为不仅仅是 EVAL 这个命令，所有的 Redis 命令，在执行之前都会被分析，籍此来确定命令会对哪些键进行操作。</p><p>因此，对于 EVAL 命令来说，必须使用正确的形式来传递键，才能确保分析工作正确地执行。除此之外，使用正确的形式来传递键还有很多其他好处，它的一个特别重要的用途就是确保 Redis 集群可以将你的请求发送到正确的集群节点。(对 Redis 集群的工作还在进行当中，但是脚本功能被设计成可以与集群功能保持兼容。)不过，这条规矩并不是强制性的，从而使得用户有机会滥用(abuse) Redis 单实例配置(single instance configuration)，代价是这样写出的脚本不能被 Redis 集群所兼容。</p><p>当 Lua 通过 call() 或 pcall() 函数执行 Redis 命令的时候，命令的返回值会被转换成 Lua 数据结构。同样地，当 Lua 脚本在 Redis 内置的解释器里运行时，Lua 脚本的返回值也会被转换成 Redis 协议(protocol)，然后由 EVAL 将值返回给客户端。</p><p>数据类型之间的转换遵循这样一个设计原则：如果将一个 Redis 值转换成 Lua 值，之后再将转换所得的 Lua 值转换回 Redis 值，那么这个转换所得的 Redis 值应该和最初时的 Redis 值一样。</p><p>换句话说， Lua 类型和 Redis 类型之间存在着一一对应的转换关系。</p><p>以下列出的是详细的转换规则：</p><p>从 Redis 转换到 Lua ：</p><p>从 Lua 转换到 Redis：</p><p>从 Lua 转换到 Redis 有一条额外的规则，这条规则没有和它对应的从 Redis 转换到 Lua 的规则：</p><p>以下是几个类型转换的例子：</p><p>在上面的三个代码示例里，前两个演示了如何将 Lua 值转换成 Redis 值，最后一个例子更复杂一些，它演示了一个将 Redis 值转换成 Lua 值，然后再将 Lua 值转换成 Redis 值的类型转过程。</p><p>Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行：当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。这和使用 MULTI / EXEC 包围的事务很类似。在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed)。</p><p>另一方面，这也意味着，执行一个运行缓慢的脚本并不是一个好主意。写一个跑得很快很顺溜的脚本并不难，因为脚本的运行开销(overhead)非常少，但是当你不得不使用一些跑得比较慢的脚本时，请小心，因为当这些蜗牛脚本在慢吞吞地运行的时候，其他客户端会因为服务器正忙而无法执行命令。</p><p>前面的命令介绍部分说过， redis.call() 和 redis.pcall() 的唯一区别在于它们对错误处理的不同。</p><p>当 redis.call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因：</p><p>和 redis.call() 不同， redis.pcall() 出错时并不引发(raise)错误，而是返回一个带 err 域的 Lua 表(table)，用于表示错误：</p><p>EVAL 命令要求你在每次执行脚本的时候都发送一次脚本主体(script body)。Redis 有一个内部的缓存机制，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。</p><p>为了减少带宽的消耗， Redis 实现了 EVALSHA 命令，它的作用和 EVAL 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)。</p><p>EVALSHA 命令的表现如下：</p><p>以下是示例：</p><p>客户端库的底层实现可以一直乐观地使用 EVALSHA 来代替 EVAL ，并期望着要使用的脚本已经保存在服务器上了，只有当 NOSCRIPT 错误发生时，才使用 EVAL 命令重新发送脚本，这样就可以最大限度地节省带宽。</p><p>这也说明了执行 EVAL 命令时，使用正确的格式来传递键名参数和附加参数的重要性：因为如果将参数硬写在脚本中，那么每次当参数改变的时候，都要重新发送脚本，即使脚本的主体并没有改变，相反，通过使用正确的格式来传递键名参数和附加参数，就可以在脚本主体不变的情况下，直接使用 EVALSHA 命令对脚本进行复用，免去了无谓的带宽消耗。</p><p>Redis 保证所有被运行过的脚本都会被永久保存在脚本缓存当中，这意味着，当 EVAL 命令在一个 Redis 实例上成功执行某个脚本之后，随后针对这个脚本的所有 EVALSHA 命令都会成功执行。</p><p>刷新脚本缓存的唯一办法是显式地调用 SCRIPT FLUSH 命令，这个命令会清空运行过的所有脚本的缓存。通常只有在云计算环境中，Redis 实例被改作其他客户或者别的应用程序的实例时，才会执行这个命令。</p><p>缓存可以长时间储存而不产生内存问题的原因是，它们的体积非常小，而且数量也非常少，即使脚本在概念上类似于实现一个新命令，即使在一个大规模的程序里有成百上千的脚本，即使这些脚本会经常修改，即便如此，储存这些脚本的内存仍然是微不足道的。</p><p>事实上，用户会发现 Redis 不移除缓存中的脚本实际上是一个好主意。比如说，对于一个和 Redis 保持持久化链接(persistent connection)的程序来说，它可以确信，执行过一次的脚本会一直保留在内存当中，因此它可以在流水线中使用 EVALSHA 命令而不必担心因为找不到所需的脚本而产生错误(稍候我们会看到在流水线中执行脚本的相关问题)。</p><p>Redis 提供了以下几个 SCRIPT 命令，用于对脚本子系统(scripting subsystem)进行控制：</p><p>在编写脚本方面，一个重要的要求就是，脚本应该被写成纯函数(pure function)。</p><p>也就是说，脚本应该具有以下属性：</p><p>使用系统时间(system time)，调用像 RANDOMKEY 那样的随机命令，或者使用 Lua 的随机数生成器，类似以上的这些操作，都会造成脚本的求值无法每次都得出同样的结果。</p><p>为了确保脚本符合上面所说的属性， Redis 做了以下工作：</p><p>尽管有那么多的限制，但用户还是可以用一个简单的技巧写出带随机行为的脚本(如果他们需要的话)。</p><p>假设现在我们要编写一个 Redis 脚本，这个脚本从列表中弹出 N 个随机数。一个 Ruby 写的例子如下：</p><p>这个程序每次运行都会生成带有以下元素的列表：</p><p>上面的 Ruby 程序每次都只生成同样的列表，用途并不是太大。那么，该怎样修改这个脚本，使得它仍然是一个纯函数(符合 Redis 的要求)，但是每次调用都可以产生不同的随机元素呢？</p><p>一个简单的办法是，为脚本添加一个额外的参数，让这个参数作为 Lua 的随机数生成器的 seed 值，这样的话，只要给脚本传入不同的 seed ，脚本就会生成不同的列表元素。</p><p>以下是修改后的脚本：</p><p>尽管对于同样的 seed ，上面的脚本产生的列表元素是一样的(因为它是一个纯函数)，但是只要每次在执行脚本的时候传入不同的 seed ，我们就可以得到带有不同随机元素的列表。</p><p>Seed 会在复制(replication link)和写 AOF 文件时作为一个参数来传播，保证在载入 AOF 文件或附属节点(slave)处理脚本时， seed 仍然可以及时得到更新。</p><p>注意，Redis 实现保证 math.random 和 math.randomseed 的输出和运行 Redis 的系统架构无关，无论是 32 位还是 64 位系统，无论是小端(little endian)还是大端(big endian)系统，这两个函数的输出总是相同的。</p><p>为了防止不必要的数据泄漏进 Lua 环境， Redis 脚本不允许创建全局变量。如果一个脚本需要在多次执行之间维持某种状态，它应该使用 Redis key 来进行状态保存。</p><p>企图在脚本中访问一个全局变量(不论这个变量是否存在)将引起脚本停止， EVAL 命令会返回一个错误：</p><p>Lua 的 debug 工具，或者其他设施，比如打印（alter）用于实现全局保护的 meta table ，都可以用于实现全局变量保护。</p><p>实现全局变量保护并不难，不过有时候还是会不小心而为之。一旦用户在脚本中混入了 Lua 全局状态，那么 AOF 持久化和复制（replication）都会无法保证，所以，请不要使用全局变量。</p><p>避免引入全局变量的一个诀窍是：将脚本中用到的所有变量都使用 local 关键字定义为局部变量。</p><p>Redis 内置的 Lua 解释器加载了以下 Lua 库：</p><p>其中 cjson 库可以让 Lua 以非常快的速度处理 JSON 数据，除此之外，其他别的都是 Lua 的标准库。</p><p>每个 Redis 实例都保证会加载上面列举的库，从而确保每个 Redis 脚本的运行环境都是相同的。</p><p>在 Lua 脚本中，可以通过调用 redis.log 函数来写 Redis 日志(log)：</p><p>redis.log(loglevel, message)</p><p>其中， message 参数是一个字符串，而 loglevel 参数可以是以下任意一个值：</p><p>上面的这些等级(level)和标准 Redis 日志的等级相对应。</p><p>对于脚本散发(emit)的日志，只有那些和当前 Redis 实例所设置的日志等级相同或更高级的日志才会被散发。</p><p>以下是一个日志示例：</p><p>redis.log(redis.LOG_WARNING, &quot;Something is wrong with this script.&quot;)</p><p>执行上面的函数会产生这样的信息：</p><p>[32343] 22 Mar 15:21:39 # Something is wrong with this script.</p><p>脚本应该仅仅用于传递参数和对 Redis 数据进行处理，它不应该尝试去访问外部系统(比如文件系统)，或者执行任何系统调用。</p><p>除此之外，脚本还有一个最大执行时间限制，它的默认值是 5 秒钟，一般正常运作的脚本通常可以在几分之几毫秒之内完成，花不了那么多时间，这个限制主要是为了防止因编程错误而造成的无限循环而设置的。</p><p>最大执行时间的长短由 lua-time-limit 选项来控制(以毫秒为单位)，可以通过编辑 redis.conf 文件或者使用 CONFIG GET 和 CONFIG SET 命令来修改它。</p><p>当一个脚本达到最大执行时间的时候，它并不会自动被 Redis 结束，因为 Redis 必须保证脚本执行的原子性，而中途停止脚本的运行意味着可能会留下未处理完的数据在数据集(data set)里面。</p><p>因此，当脚本运行的时间超过最大执行时间后，以下动作会被执行：</p><p>在流水线请求的上下文中使用 EVALSHA 命令时，要特别小心，因为在流水线中，必须保证命令的执行顺序。</p><p>一旦在流水线中因为 EVALSHA 命令而发生 NOSCRIPT 错误，那么这个流水线就再也没有办法重新执行了，否则的话，命令的执行顺序就会被打乱。</p><p>为了防止出现以上所说的问题，客户端库实现应该实施以下的其中一项措施：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EVAL script numkeys key [key ...] arg [arg ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt; eval &quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot; 2 key1 key2 first second</span></span>
<span class="line"><span>1) &quot;key1&quot;</span></span>
<span class="line"><span>2) &quot;key2&quot;</span></span>
<span class="line"><span>3) &quot;first&quot;</span></span>
<span class="line"><span>4) &quot;second&quot;</span></span></code></pre></div><h3 id="evalsha" tabindex="-1">EVALSHA <a class="header-anchor" href="#evalsha" aria-label="Permalink to &quot;EVALSHA&quot;">​</a></h3><p>根据给定的 sha1 校验码，对缓存在服务器中的脚本进行求值。</p><p>将脚本缓存到服务器的操作可以通过 SCRIPT LOAD 命令进行。</p><p>这个命令的其他地方，比如参数的传入方式，都和 EVAL 命令一样。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EVALSHA sha1 numkeys key [key ...] arg [arg ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SCRIPT LOAD &quot;return &#39;hello moto&#39;&quot;</span></span>
<span class="line"><span>&quot;232fd51614574cf0867b83d384a5e898cfd24e5a&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EVALSHA &quot;232fd51614574cf0867b83d384a5e898cfd24e5a&quot; 0</span></span>
<span class="line"><span>&quot;hello moto&quot;</span></span></code></pre></div><h3 id="script-exists" tabindex="-1">SCRIPT EXISTS <a class="header-anchor" href="#script-exists" aria-label="Permalink to &quot;SCRIPT EXISTS&quot;">​</a></h3><p>给定一个或多个脚本的 SHA1 校验和，返回一个包含 0 和 1 的列表，表示校验和所指定的脚本是否已经被保存在缓存当中。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SCRIPT EXISTS script [script ...]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SCRIPT LOAD &quot;return &#39;hello moto&#39;&quot;    # 载入一个脚本</span></span>
<span class="line"><span>&quot;232fd51614574cf0867b83d384a5e898cfd24e5a&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SCRIPT EXISTS 232fd51614574cf0867b83d384a5e898cfd24e5a</span></span>
<span class="line"><span>1) (integer) 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SCRIPT FLUSH     # 清空缓存</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SCRIPT EXISTS 232fd51614574cf0867b83d384a5e898cfd24e5a</span></span>
<span class="line"><span>1) (integer) 0</span></span></code></pre></div><h3 id="script-flush" tabindex="-1">SCRIPT FLUSH <a class="header-anchor" href="#script-flush" aria-label="Permalink to &quot;SCRIPT FLUSH&quot;">​</a></h3><p>清除所有 Lua 脚本缓存。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SCRIPT FLUSH</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SCRIPT FLUSH</span></span>
<span class="line"><span>OK</span></span></code></pre></div><h3 id="script-kill" tabindex="-1">SCRIPT KILL <a class="header-anchor" href="#script-kill" aria-label="Permalink to &quot;SCRIPT KILL&quot;">​</a></h3><p>杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。</p><p>这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本，诸如此类。</p><p>SCRIPT KILL 执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从 EVAL 命令的阻塞当中退出，并收到一个错误作为返回值。</p><p>另一方面，假如当前正在运行的脚本已经执行过写操作，那么即使执行 SCRIPT KILL ，也无法将它杀死，因为这是违反 Lua 脚本的原子性执行原则的。在这种情况下，唯一可行的办法是使用 SHUTDOWN NOSAVE 命令，通过停止整个 Redis 进程来停止脚本的运行，并防止不完整(half-written)的信息被写入数据库中。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL 命令。</p><p>以下是脚本被杀死之后，返回给执行脚本的客户端的错误：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SCRIPT KILL</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 没有脚本在执行时</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SCRIPT KILL</span></span>
<span class="line"><span>(error) ERR No scripts in execution right now.</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 成功杀死脚本时</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SCRIPT KILL</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span>(1.30s)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 尝试杀死一个已经执行过写操作的脚本，失败</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SCRIPT KILL</span></span>
<span class="line"><span>(error) ERR Sorry the script already executed write commands against the dataset. You can either wait the script termination or kill the server in an hard way using the SHUTDOWN NOSAVE command.</span></span>
<span class="line"><span>(1.69s)</span></span></code></pre></div><h3 id="script-load" tabindex="-1">SCRIPT LOAD <a class="header-anchor" href="#script-load" aria-label="Permalink to &quot;SCRIPT LOAD&quot;">​</a></h3><p>将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</p><p>EVAL 命令也会将脚本添加到脚本缓存中，但是它会立即对输入的脚本进行求值。</p><p>如果给定的脚本已经在缓存里面了，那么不做动作。</p><p>在脚本被加入到缓存之后，通过 EVALSHA 命令，可以使用脚本的 SHA1 校验和来调用这个脚本。</p><p>脚本可以在缓存中保留无限长的时间，直到执行 SCRIPT FLUSH 为止。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL 命令。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SCRIPT LOAD script</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SCRIPT LOAD &quot;return &#39;hello moto&#39;&quot;</span></span>
<span class="line"><span>&quot;232fd51614574cf0867b83d384a5e898cfd24e5a&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; EVALSHA 232fd51614574cf0867b83d384a5e898cfd24e5a 0</span></span>
<span class="line"><span>&quot;hello moto&quot;</span></span></code></pre></div><h2 id="connection-连接" tabindex="-1">Connection（连接） <a class="header-anchor" href="#connection-连接" aria-label="Permalink to &quot;Connection（连接）&quot;">​</a></h2><h3 id="auth" tabindex="-1">AUTH <a class="header-anchor" href="#auth" aria-label="Permalink to &quot;AUTH&quot;">​</a></h3><p>通过设置配置文件中 requirepass 项的值(使用命令 CONFIG SET requirepass password )，可以使用密码来保护 Redis 服务器。</p><p>如果开启了密码保护的话，在每次连接 Redis 服务器之后，就要使用 AUTH 命令解锁，解锁之后才能使用其他 Redis 命令。</p><p>如果 AUTH 命令给定的密码 password 和配置文件中的密码相符的话，服务器会返回 OK 并开始接受命令输入。</p><p>另一方面，假如密码不匹配的话，服务器将返回一个错误，并要求客户端需重新输入密码。</p><p>Warning</p><p>因为 Redis 高性能的特点，在很短时间内尝试猜测非常多个密码是有可能的，因此请确保使用的密码足够复杂和足够长，以免遭受密码猜测攻击。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>AUTH password</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 设置密码</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; CONFIG SET requirepass secret_password   # 将密码设置为 secret_password</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; QUIT                                     # 退出再连接，让新密码对客户端生效</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[huangz@mypad]$ redis</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PING                                     # 未验证密码，操作被拒绝</span></span>
<span class="line"><span>(error) ERR operation not permitted</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; AUTH wrong_password_testing              # 尝试输入错误的密码</span></span>
<span class="line"><span>(error) ERR invalid password</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; AUTH secret_password                     # 输入正确的密码</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PING                                     # 密码验证成功，可以正常操作命令了</span></span>
<span class="line"><span>PONG</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 清空密码</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; CONFIG SET requirepass &quot;&quot;   # 通过将密码设为空字符来清空密码</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; QUIT</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$ redis                            # 重新进入客户端</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PING                        # 执行命令不再需要密码，清空密码操作成功</span></span>
<span class="line"><span>PONG</span></span></code></pre></div><h3 id="echo" tabindex="-1">ECHO <a class="header-anchor" href="#echo" aria-label="Permalink to &quot;ECHO&quot;">​</a></h3><p>打印一个特定的信息 message ，测试时使用。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ECHO message</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; ECHO &quot;Hello Moto&quot;</span></span>
<span class="line"><span>&quot;Hello Moto&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; ECHO &quot;Goodbye Moto&quot;</span></span>
<span class="line"><span>&quot;Goodbye Moto&quot;</span></span></code></pre></div><h3 id="ping" tabindex="-1">PING <a class="header-anchor" href="#ping" aria-label="Permalink to &quot;PING&quot;">​</a></h3><p>使用客户端向 Redis 服务器发送一个 PING ，如果服务器运作正常的话，会返回一个 PONG 。</p><p>通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PING</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 客户端和服务器连接正常</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; PING</span></span>
<span class="line"><span>PONG</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 客户端和服务器连接不正常(网络不正常或服务器未能正常运行)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; PING</span></span>
<span class="line"><span>Could not connect to Redis at 127.0.0.1:6379: Connection refused</span></span></code></pre></div><h3 id="quit" tabindex="-1">QUIT <a class="header-anchor" href="#quit" aria-label="Permalink to &quot;QUIT&quot;">​</a></h3><p>请求服务器关闭与当前客户端的连接。</p><p>一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>QUIT</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ redis</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; QUIT</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$</span></span></code></pre></div><h3 id="select" tabindex="-1">SELECT <a class="header-anchor" href="#select" aria-label="Permalink to &quot;SELECT&quot;">​</a></h3><p>切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。</p><p>默认使用 0 号数据库。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT index</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SET db_number 0         # 默认使用 0 号数据库</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SELECT 1                # 使用 1 号数据库</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis[1]&gt; GET db_number        # 已经切换到 1 号数据库，注意 Redis 现在的命令提示符多了个 [1]</span></span>
<span class="line"><span>(nil)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis[1]&gt; SET db_number 1</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis[1]&gt; GET db_number</span></span>
<span class="line"><span>&quot;1&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis[1]&gt; SELECT 3             # 再切换到 3 号数据库</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis[3]&gt;                      # 提示符从 [1] 改变成了 [3]</span></span></code></pre></div><h2 id="server-服务器" tabindex="-1">Server（服务器） <a class="header-anchor" href="#server-服务器" aria-label="Permalink to &quot;Server（服务器）&quot;">​</a></h2><h3 id="bgrewriteaof" tabindex="-1">BGREWRITEAOF <a class="header-anchor" href="#bgrewriteaof" aria-label="Permalink to &quot;BGREWRITEAOF&quot;">​</a></h3><p>执行一个 AOF文件 重写操作。重写会创建一个当前 AOF 文件的体积优化版本。</p><p>即使 BGREWRITEAOF 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 BGREWRITEAOF 成功之前不会被修改。</p><p>重写操作只会在没有其他持久化工作在后台执行时被触发，也就是说：</p><p>从 Redis 2.4 开始， AOF 重写由 Redis 自行触发， BGREWRITEAOF 仅仅用于手动触发重写操作。</p><p>请移步 持久化文档(英文) 查看更多相关细节。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BGREWRITEAOF</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; BGREWRITEAOF</span></span>
<span class="line"><span>Background append only file rewriting started</span></span></code></pre></div><h3 id="bgsave" tabindex="-1">BGSAVE <a class="header-anchor" href="#bgsave" aria-label="Permalink to &quot;BGSAVE&quot;">​</a></h3><p>BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。</p><p>客户端可以通过 LASTSAVE 命令查看相关信息，判断 BGSAVE 命令是否执行成功。</p><p>请移步 持久化文档 查看更多相关细节。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>在后台异步(Asynchronously)保存当前数据库的数据到磁盘。</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; BGSAVE</span></span>
<span class="line"><span>Background saving started</span></span></code></pre></div><h3 id="client-getname" tabindex="-1">CLIENT GETNAME <a class="header-anchor" href="#client-getname" aria-label="Permalink to &quot;CLIENT GETNAME&quot;">​</a></h3><p>返回 CLIENT SETNAME 命令为连接设置的名字。</p><p>因为新创建的连接默认是没有名字的， 对于没有名字的连接， CLIENT GETNAME 返回空白回复。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CLIENT GETNAME</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 新连接默认没有名字</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CLIENT GETNAME</span></span>
<span class="line"><span>(nil)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 设置名字</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CLIENT SETNAME hello-world-connection</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 返回名字</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CLIENT GETNAME</span></span>
<span class="line"><span>&quot;hello-world-connection&quot;</span></span></code></pre></div><h3 id="client-kill" tabindex="-1">CLIENT KILL <a class="header-anchor" href="#client-kill" aria-label="Permalink to &quot;CLIENT KILL&quot;">​</a></h3><p>关闭地址为 ip:port 的客户端。</p><p>ip:port 应该和 CLIENT LIST 命令输出的其中一行匹配。</p><p>因为 Redis 使用单线程设计，所以当 Redis 正在执行命令的时候，不会有客户端被断开连接。</p><p>如果要被断开连接的客户端正在执行命令，那么当这个命令执行之后，在发送下一个命令的时候，它就会收到一个网络错误，告知它自身的连接已被关闭。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CLIENT KILL ip:port</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 列出所有已连接客户端</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CLIENT LIST</span></span>
<span class="line"><span>addr=127.0.0.1:43501 fd=5 age=10 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 杀死当前客户端的连接</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CLIENT KILL 127.0.0.1:43501</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 之前的连接已经被关闭，CLI 客户端又重新建立了连接</span></span>
<span class="line"><span># 之前的端口是 43501 ，现在是 43504</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CLIENT LIST</span></span>
<span class="line"><span>addr=127.0.0.1:43504 fd=5 age=0 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span></span></code></pre></div><h3 id="client-list" tabindex="-1">CLIENT LIST <a class="header-anchor" href="#client-list" aria-label="Permalink to &quot;CLIENT LIST&quot;">​</a></h3><p>以人类可读的格式，返回所有连接到服务器的客户端信息和统计数据。</p><p>命令返回多行字符串，这些字符串按以下形式被格式化：</p><p>以下是域的含义：</p><p>客户端 flag 可以由以下部分组成：</p><p>文件描述符事件可以是：</p><p>Note</p><p>为了 debug 的需要，经常会对域进行添加和删除，一个安全的 Redis 客户端应该可以对 CLIENT LIST 的输出进行相应的处理（parse），比如忽略不存在的域，跳过未知域，诸如此类。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CLIENT LIST</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; CLIENT LIST</span></span>
<span class="line"><span>addr=127.0.0.1:43143 fd=6 age=183 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span></span>
<span class="line"><span>addr=127.0.0.1:43163 fd=5 age=35 idle=15 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping</span></span>
<span class="line"><span>addr=127.0.0.1:43167 fd=7 age=24 idle=6 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=get</span></span></code></pre></div><h3 id="client-setname" tabindex="-1">CLIENT SETNAME <a class="header-anchor" href="#client-setname" aria-label="Permalink to &quot;CLIENT SETNAME&quot;">​</a></h3><p>为当前连接分配一个名字。</p><p>这个名字会显示在 CLIENT LIST 命令的结果中， 用于识别当前正在与服务器进行连接的客户端。</p><p>举个例子， 在使用 Redis 构建队列（queue）时， 可以根据连接负责的任务（role）， 为信息生产者（producer）和信息消费者（consumer）分别设置不同的名字。</p><p>名字使用 Redis 的字符串类型来保存， 最大可以占用 512 MB 。 另外， 为了避免和 CLIENT LIST 命令的输出格式发生冲突， 名字里不允许使用空格。</p><p>要移除一个连接的名字， 可以将连接的名字设为空字符串 &quot;&quot; 。</p><p>使用 CLIENT GETNAME 命令可以取出连接的名字。</p><p>新创建的连接默认是没有名字的。</p><p>Tip</p><p>在 Redis 应用程序发生连接泄漏时，为连接设置名字是一种很好的 debug 手段。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CLIENT SETNAME connection-name</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 新连接默认没有名字</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CLIENT GETNAME</span></span>
<span class="line"><span>(nil)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 设置名字</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CLIENT SETNAME hello-world-connection</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 返回名字</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CLIENT GETNAME</span></span>
<span class="line"><span>&quot;hello-world-connection&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 在客户端列表中查看</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CLIENT LIST</span></span>
<span class="line"><span>addr=127.0.0.1:36851</span></span>
<span class="line"><span>fd=5</span></span>
<span class="line"><span>name=hello-world-connection     # &lt;- 名字</span></span>
<span class="line"><span>age=51</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 清除名字</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CLIENT SETNAME        # 只用空格是不行的！</span></span>
<span class="line"><span>(error) ERR Syntax error, try CLIENT (LIST | KILL ip:port)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CLIENT SETNAME &quot;&quot;     # 必须双引号显示包围</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CLIENT GETNAME        # 清除完毕</span></span>
<span class="line"><span>(nil)</span></span></code></pre></div><h3 id="config-get" tabindex="-1">CONFIG GET <a class="header-anchor" href="#config-get" aria-label="Permalink to &quot;CONFIG GET&quot;">​</a></h3><p>CONFIG GET 命令用于取得运行中的 Redis 服务器的配置参数(configuration parameters)，在 Redis 2.4 版本中， 有部分参数没有办法用 CONFIG GET 访问，但是在最新的 Redis 2.6 版本中，所有配置参数都已经可以用 CONFIG GET 访问了。</p><p>CONFIG GET 接受单个参数 parameter 作为搜索关键字，查找所有匹配的配置参数，其中参数和值以“键-值对”(key-value pairs)的方式排列。</p><p>比如执行 CONFIG GET s* 命令，服务器就会返回所有以 s 开头的配置参数及参数的值：</p><p>如果你只是寻找特定的某个参数的话，你当然也可以直接指定参数的名字：</p><p>使用命令 CONFIG GET * ，可以列出 CONFIG GET 命令支持的所有参数：</p><p>所有被 CONFIG SET 所支持的配置参数都可以在配置文件 redis.conf 中找到，不过 CONFIG GET 和 CONFIG SET 使用的格式和 redis.conf 文件所使用的格式有以下两点不同：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CONFIG GET parameter</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; CONFIG GET s*</span></span>
<span class="line"><span>1) &quot;save&quot;                       # 参数名：save</span></span>
<span class="line"><span>2) &quot;900 1 300 10 60 10000&quot;      # save 参数的值</span></span>
<span class="line"><span>3) &quot;slave-serve-stale-data&quot;     # 参数名： slave-serve-stale-data</span></span>
<span class="line"><span>4) &quot;yes&quot;                        # slave-serve-stale-data 参数的值</span></span>
<span class="line"><span>5) &quot;set-max-intset-entries&quot;     # ...</span></span>
<span class="line"><span>6) &quot;512&quot;</span></span>
<span class="line"><span>7) &quot;slowlog-log-slower-than&quot;</span></span>
<span class="line"><span>8) &quot;1000&quot;</span></span>
<span class="line"><span>9) &quot;slowlog-max-len&quot;</span></span>
<span class="line"><span>10) &quot;1000&quot;</span></span></code></pre></div><h3 id="config-resetstat" tabindex="-1">CONFIG RESETSTAT <a class="header-anchor" href="#config-resetstat" aria-label="Permalink to &quot;CONFIG RESETSTAT&quot;">​</a></h3><p>重置 INFO 命令中的某些统计数据，包括：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CONFIG RESETSTAT</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 重置前</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; INFO</span></span>
<span class="line"><span># Server</span></span>
<span class="line"><span>redis_version:2.5.3</span></span>
<span class="line"><span>redis_git_sha1:d0407c2d</span></span>
<span class="line"><span>redis_git_dirty:0</span></span>
<span class="line"><span>arch_bits:32</span></span>
<span class="line"><span>multiplexing_api:epoll</span></span>
<span class="line"><span>gcc_version:4.6.3</span></span>
<span class="line"><span>process_id:11095</span></span>
<span class="line"><span>run_id:ef1f6b6c7392e52d6001eaf777acbe547d1192e2</span></span>
<span class="line"><span>tcp_port:6379</span></span>
<span class="line"><span>uptime_in_seconds:6</span></span>
<span class="line"><span>uptime_in_days:0</span></span>
<span class="line"><span>lru_clock:1205426</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Clients</span></span>
<span class="line"><span>connected_clients:1</span></span>
<span class="line"><span>client_longest_output_list:0</span></span>
<span class="line"><span>client_biggest_input_buf:0</span></span>
<span class="line"><span>blocked_clients:0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Memory</span></span>
<span class="line"><span>used_memory:331076</span></span>
<span class="line"><span>used_memory_human:323.32K</span></span>
<span class="line"><span>used_memory_rss:1568768</span></span>
<span class="line"><span>used_memory_peak:293424</span></span>
<span class="line"><span>used_memory_peak_human:286.55K</span></span>
<span class="line"><span>used_memory_lua:16384</span></span>
<span class="line"><span>mem_fragmentation_ratio:4.74</span></span>
<span class="line"><span>mem_allocator:jemalloc-2.2.5</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Persistence</span></span>
<span class="line"><span>loading:0</span></span>
<span class="line"><span>aof_enabled:0</span></span>
<span class="line"><span>changes_since_last_save:0</span></span>
<span class="line"><span>bgsave_in_progress:0</span></span>
<span class="line"><span>last_save_time:1333260015</span></span>
<span class="line"><span>last_bgsave_status:ok</span></span>
<span class="line"><span>bgrewriteaof_in_progress:0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Stats</span></span>
<span class="line"><span>total_connections_received:1</span></span>
<span class="line"><span>total_commands_processed:0</span></span>
<span class="line"><span>instantaneous_ops_per_sec:0</span></span>
<span class="line"><span>rejected_connections:0</span></span>
<span class="line"><span>expired_keys:0</span></span>
<span class="line"><span>evicted_keys:0</span></span>
<span class="line"><span>keyspace_hits:0</span></span>
<span class="line"><span>keyspace_misses:0</span></span>
<span class="line"><span>pubsub_channels:0</span></span>
<span class="line"><span>pubsub_patterns:0</span></span>
<span class="line"><span>latest_fork_usec:0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Replication</span></span>
<span class="line"><span>role:master</span></span>
<span class="line"><span>connected_slaves:0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># CPU</span></span>
<span class="line"><span>used_cpu_sys:0.01</span></span>
<span class="line"><span>used_cpu_user:0.00</span></span>
<span class="line"><span>used_cpu_sys_children:0.00</span></span>
<span class="line"><span>used_cpu_user_children:0.00</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Keyspace</span></span>
<span class="line"><span>db0:keys=20,expires=0</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 重置</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; CONFIG RESETSTAT</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 重置后</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; INFO</span></span>
<span class="line"><span># Server</span></span>
<span class="line"><span>redis_version:2.5.3</span></span>
<span class="line"><span>redis_git_sha1:d0407c2d</span></span>
<span class="line"><span>redis_git_dirty:0</span></span>
<span class="line"><span>arch_bits:32</span></span>
<span class="line"><span>multiplexing_api:epoll</span></span>
<span class="line"><span>gcc_version:4.6.3</span></span>
<span class="line"><span>process_id:11095</span></span>
<span class="line"><span>run_id:ef1f6b6c7392e52d6001eaf777acbe547d1192e2</span></span>
<span class="line"><span>tcp_port:6379</span></span>
<span class="line"><span>uptime_in_seconds:134</span></span>
<span class="line"><span>uptime_in_days:0</span></span>
<span class="line"><span>lru_clock:1205438</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Clients</span></span>
<span class="line"><span>connected_clients:1</span></span>
<span class="line"><span>client_longest_output_list:0</span></span>
<span class="line"><span>client_biggest_input_buf:0</span></span>
<span class="line"><span>blocked_clients:0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Memory</span></span>
<span class="line"><span>used_memory:331076</span></span>
<span class="line"><span>used_memory_human:323.32K</span></span>
<span class="line"><span>used_memory_rss:1568768</span></span>
<span class="line"><span>used_memory_peak:330280</span></span>
<span class="line"><span>used_memory_peak_human:322.54K</span></span>
<span class="line"><span>used_memory_lua:16384</span></span>
<span class="line"><span>mem_fragmentation_ratio:4.74</span></span>
<span class="line"><span>mem_allocator:jemalloc-2.2.5</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Persistence</span></span>
<span class="line"><span>loading:0</span></span>
<span class="line"><span>aof_enabled:0</span></span>
<span class="line"><span>changes_since_last_save:0</span></span>
<span class="line"><span>bgsave_in_progress:0</span></span>
<span class="line"><span>last_save_time:1333260015</span></span>
<span class="line"><span>last_bgsave_status:ok</span></span>
<span class="line"><span>bgrewriteaof_in_progress:0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Stats</span></span>
<span class="line"><span>total_connections_received:0</span></span>
<span class="line"><span>total_commands_processed:1</span></span>
<span class="line"><span>instantaneous_ops_per_sec:0</span></span>
<span class="line"><span>rejected_connections:0</span></span>
<span class="line"><span>expired_keys:0</span></span>
<span class="line"><span>evicted_keys:0</span></span>
<span class="line"><span>keyspace_hits:0</span></span>
<span class="line"><span>keyspace_misses:0</span></span>
<span class="line"><span>pubsub_channels:0</span></span>
<span class="line"><span>pubsub_patterns:0</span></span>
<span class="line"><span>latest_fork_usec:0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Replication</span></span>
<span class="line"><span>role:master</span></span>
<span class="line"><span>connected_slaves:0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># CPU</span></span>
<span class="line"><span>used_cpu_sys:0.05</span></span>
<span class="line"><span>used_cpu_user:0.02</span></span>
<span class="line"><span>used_cpu_sys_children:0.00</span></span>
<span class="line"><span>used_cpu_user_children:0.00</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Keyspace</span></span>
<span class="line"><span>db0:keys=20,expires=0</span></span></code></pre></div><h3 id="config-rewrite" tabindex="-1">CONFIG REWRITE <a class="header-anchor" href="#config-rewrite" aria-label="Permalink to &quot;CONFIG REWRITE&quot;">​</a></h3><p>CONFIG REWRITE 命令对启动 Redis 服务器时所指定的 redis.conf 文件进行改写： 因为 CONFIG SET 命令可以对服务器的当前配置进行修改， 而修改后的配置可能和 redis.conf 文件中所描述的配置不一样， CONFIG REWRITE 的作用就是通过尽可能少的修改， 将服务器当前所使用的配置记录到 redis.conf 文件中。</p><p>重写会以非常保守的方式进行：</p><p>即使启动服务器时所指定的 redis.conf 文件已经不再存在， CONFIG REWRITE 命令也可以重新构建并生成出一个新的 redis.conf 文件。</p><p>另一方面， 如果启动服务器时没有载入 redis.conf 文件， 那么执行 CONFIG REWRITE 命令将引发一个错误。</p><p>对 redis.conf 文件的重写是原子性的， 并且是一致的： 如果重写出错或重写期间服务器崩溃， 那么重写失败， 原有 redis.conf 文件不会被修改。 如果重写成功， 那么 redis.conf 文件为重写后的新文件。</p><blockquote><p>= 2.8.0</p></blockquote><p>一个状态值：如果配置重写成功则返回 OK ，失败则返回一个错误。</p><p>以下是执行 CONFIG REWRITE 前， 被载入到 Redis 服务器的 redis.conf 文件中关于 appendonly 选项的设置：</p><p>在执行以下命令之后：</p><p>重写后的 redis.conf 文件中的 appendonly 选项将被改写：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CONFIG REWRITE</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># ... 其他选项</span></span>
<span class="line"><span></span></span>
<span class="line"><span>appendonly no</span></span>
<span class="line"><span></span></span>
<span class="line"><span># ... 其他选项</span></span></code></pre></div><h3 id="config-set" tabindex="-1">CONFIG SET <a class="header-anchor" href="#config-set" aria-label="Permalink to &quot;CONFIG SET&quot;">​</a></h3><p>CONFIG SET 命令可以动态地调整 Redis 服务器的配置(configuration)而无须重启。</p><p>你可以使用它修改配置参数，或者改变 Redis 的持久化(Persistence)方式。</p><p>CONFIG SET 可以修改的配置参数可以使用命令 CONFIG GET * 来列出，所有被 CONFIG SET 修改的配置参数都会立即生效。</p><p>关于 CONFIG SET 命令的更多消息，请参见命令 CONFIG GET 的说明。</p><p>关于如何使用 CONFIG SET 命令修改 Redis 持久化方式，请参见 Redis Persistence 。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CONFIG SET parameter value</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; CONFIG GET slowlog-max-len</span></span>
<span class="line"><span>1) &quot;slowlog-max-len&quot;</span></span>
<span class="line"><span>2) &quot;1024&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; CONFIG SET slowlog-max-len 10086</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; CONFIG GET slowlog-max-len</span></span>
<span class="line"><span>1) &quot;slowlog-max-len&quot;</span></span>
<span class="line"><span>2) &quot;10086&quot;</span></span></code></pre></div><h3 id="dbsize" tabindex="-1">DBSIZE <a class="header-anchor" href="#dbsize" aria-label="Permalink to &quot;DBSIZE&quot;">​</a></h3><p>返回当前数据库的 key 的数量。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DBSIZE</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; DBSIZE</span></span>
<span class="line"><span>(integer) 5</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SET new_key &quot;hello_moto&quot;     # 增加一个 key 试试</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DBSIZE</span></span>
<span class="line"><span>(integer) 6</span></span></code></pre></div><h3 id="debug-object" tabindex="-1">DEBUG OBJECT <a class="header-anchor" href="#debug-object" aria-label="Permalink to &quot;DEBUG OBJECT&quot;">​</a></h3><p>DEBUG OBJECT 是一个调试命令，它不应被客户端所使用。</p><p>查看 OBJECT 命令获取更多信息。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DEBUG OBJECT key</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; DEBUG OBJECT my_pc</span></span>
<span class="line"><span>Value at:0xb6838d20 refcount:1 encoding:raw serializedlength:9 lru:283790 lru_seconds_idle:150</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DEBUG OBJECT your_mac</span></span>
<span class="line"><span>(error) ERR no such key</span></span></code></pre></div><h3 id="debug-segfault" tabindex="-1">DEBUG SEGFAULT <a class="header-anchor" href="#debug-segfault" aria-label="Permalink to &quot;DEBUG SEGFAULT&quot;">​</a></h3><p>执行一个不合法的内存访问从而让 Redis 崩溃，仅在开发时用于 BUG 模拟。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DEBUG SEGFAULT</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; DEBUG SEGFAULT</span></span>
<span class="line"><span>Could not connect to Redis at: Connection refused</span></span>
<span class="line"><span></span></span>
<span class="line"><span>not connected&gt;</span></span></code></pre></div><h3 id="flushall" tabindex="-1">FLUSHALL <a class="header-anchor" href="#flushall" aria-label="Permalink to &quot;FLUSHALL&quot;">​</a></h3><p>清空整个 Redis 服务器的数据(删除所有数据库的所有 key )。</p><p>此命令从不失败。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>FLUSHALL</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; DBSIZE            # 0 号数据库的 key 数量</span></span>
<span class="line"><span>(integer) 9</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SELECT 1          # 切换到 1 号数据库</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis[1]&gt; DBSIZE         # 1 号数据库的 key 数量</span></span>
<span class="line"><span>(integer) 6</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis[1]&gt; flushall       # 清空所有数据库的所有 key</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis[1]&gt; DBSIZE         # 不但 1 号数据库被清空了</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis[1]&gt; SELECT 0       # 0 号数据库(以及其他所有数据库)也一样</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DBSIZE</span></span>
<span class="line"><span>(integer) 0</span></span></code></pre></div><h3 id="flushdb" tabindex="-1">FLUSHDB <a class="header-anchor" href="#flushdb" aria-label="Permalink to &quot;FLUSHDB&quot;">​</a></h3><p>清空当前数据库中的所有 key。</p><p>此命令从不失败。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>FLUSHDB</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; DBSIZE    # 清空前的 key 数量</span></span>
<span class="line"><span>(integer) 4</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; FLUSHDB</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; DBSIZE    # 清空后的 key 数量</span></span>
<span class="line"><span>(integer) 0</span></span></code></pre></div><h3 id="info" tabindex="-1">INFO <a class="header-anchor" href="#info" aria-label="Permalink to &quot;INFO&quot;">​</a></h3><p>以一种易于解释（parse）且易于阅读的格式，返回关于 Redis 服务器的各种信息和统计数值。</p><p>通过给定可选的参数 section ，可以让命令只返回某一部分的信息：</p><p>server : 一般 Redis 服务器信息，包含以下域：</p><p>clients : 已连接客户端信息，包含以下域：</p><p>memory : 内存信息，包含以下域：</p><p>Because Redis does not have control over how its allocations are mapped to memory pages, high used_memory_rss is often the result of a spike in memory usage.</p><p>persistence : RDB 和 AOF 的相关信息</p><p>stats : 一般统计信息</p><p>replication : 主/从复制信息</p><p>cpu : CPU 计算量统计信息</p><p>commandstats : Redis 命令统计信息</p><p>cluster : Redis 集群信息</p><p>keyspace : 数据库相关的统计信息</p><p>除上面给出的这些值以外，参数还可以是下面这两个：</p><p>当不带参数直接调用 INFO 命令时，使用 default 作为默认参数。</p><p>Note</p><p>不同版本的 Redis 可能对返回的一些域进行了增加或删减。</p><p>因此，一个健壮的客户端程序在对 INFO 命令的输出进行分析时，应该能够跳过不认识的域，并且妥善地处理丢失不见的域。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>INFO [section]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; INFO</span></span>
<span class="line"><span># Server</span></span>
<span class="line"><span>redis_version:2.5.9</span></span>
<span class="line"><span>redis_git_sha1:473f3090</span></span>
<span class="line"><span>redis_git_dirty:0</span></span>
<span class="line"><span>os:Linux 3.3.7-1-ARCH i686</span></span>
<span class="line"><span>arch_bits:32</span></span>
<span class="line"><span>multiplexing_api:epoll</span></span>
<span class="line"><span>gcc_version:4.7.0</span></span>
<span class="line"><span>process_id:8104</span></span>
<span class="line"><span>run_id:bc9e20c6f0aac67d0d396ab950940ae4d1479ad1</span></span>
<span class="line"><span>tcp_port:6379</span></span>
<span class="line"><span>uptime_in_seconds:7</span></span>
<span class="line"><span>uptime_in_days:0</span></span>
<span class="line"><span>lru_clock:1680564</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Clients</span></span>
<span class="line"><span>connected_clients:1</span></span>
<span class="line"><span>client_longest_output_list:0</span></span>
<span class="line"><span>client_biggest_input_buf:0</span></span>
<span class="line"><span>blocked_clients:0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Memory</span></span>
<span class="line"><span>used_memory:439304</span></span>
<span class="line"><span>used_memory_human:429.01K</span></span>
<span class="line"><span>used_memory_rss:13897728</span></span>
<span class="line"><span>used_memory_peak:401776</span></span>
<span class="line"><span>used_memory_peak_human:392.36K</span></span>
<span class="line"><span>used_memory_lua:20480</span></span>
<span class="line"><span>mem_fragmentation_ratio:31.64</span></span>
<span class="line"><span>mem_allocator:jemalloc-3.0.0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Persistence</span></span>
<span class="line"><span>loading:0</span></span>
<span class="line"><span>rdb_changes_since_last_save:0</span></span>
<span class="line"><span>rdb_bgsave_in_progress:0</span></span>
<span class="line"><span>rdb_last_save_time:1338011402</span></span>
<span class="line"><span>rdb_last_bgsave_status:ok</span></span>
<span class="line"><span>rdb_last_bgsave_time_sec:-1</span></span>
<span class="line"><span>rdb_current_bgsave_time_sec:-1</span></span>
<span class="line"><span>aof_enabled:0</span></span>
<span class="line"><span>aof_rewrite_in_progress:0</span></span>
<span class="line"><span>aof_rewrite_scheduled:0</span></span>
<span class="line"><span>aof_last_rewrite_time_sec:-1</span></span>
<span class="line"><span>aof_current_rewrite_time_sec:-1</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Stats</span></span>
<span class="line"><span>total_connections_received:1</span></span>
<span class="line"><span>total_commands_processed:0</span></span>
<span class="line"><span>instantaneous_ops_per_sec:0</span></span>
<span class="line"><span>rejected_connections:0</span></span>
<span class="line"><span>expired_keys:0</span></span>
<span class="line"><span>evicted_keys:0</span></span>
<span class="line"><span>keyspace_hits:0</span></span>
<span class="line"><span>keyspace_misses:0</span></span>
<span class="line"><span>pubsub_channels:0</span></span>
<span class="line"><span>pubsub_patterns:0</span></span>
<span class="line"><span>latest_fork_usec:0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Replication</span></span>
<span class="line"><span>role:master</span></span>
<span class="line"><span>connected_slaves:0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># CPU</span></span>
<span class="line"><span>used_cpu_sys:0.03</span></span>
<span class="line"><span>used_cpu_user:0.01</span></span>
<span class="line"><span>used_cpu_sys_children:0.00</span></span>
<span class="line"><span>used_cpu_user_children:0.00</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Keyspace</span></span></code></pre></div><h3 id="lastsave" tabindex="-1">LASTSAVE <a class="header-anchor" href="#lastsave" aria-label="Permalink to &quot;LASTSAVE&quot;">​</a></h3><p>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LASTSAVE</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; LASTSAVE</span></span>
<span class="line"><span>(integer) 1324043588</span></span></code></pre></div><h3 id="monitor" tabindex="-1">MONITOR <a class="header-anchor" href="#monitor" aria-label="Permalink to &quot;MONITOR&quot;">​</a></h3><p>实时打印出 Redis 服务器接收到的命令，调试用。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MONITOR</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>127.0.0.1:6379&gt; MONITOR</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span># 以第一个打印值为例</span></span>
<span class="line"><span># 1378822099.421623 是时间戳</span></span>
<span class="line"><span># [0 127.0.0.1:56604] 中的 0 是数据库号码， 127... 是 IP 地址和端口</span></span>
<span class="line"><span># &quot;PING&quot; 是被执行的命令</span></span>
<span class="line"><span>1378822099.421623 [0 127.0.0.1:56604] &quot;PING&quot;</span></span>
<span class="line"><span>1378822105.089572 [0 127.0.0.1:56604] &quot;SET&quot; &quot;msg&quot; &quot;hello world&quot;</span></span>
<span class="line"><span>1378822109.036925 [0 127.0.0.1:56604] &quot;SET&quot; &quot;number&quot; &quot;123&quot;</span></span>
<span class="line"><span>1378822140.649496 [0 127.0.0.1:56604] &quot;SADD&quot; &quot;fruits&quot; &quot;Apple&quot; &quot;Banana&quot; &quot;Cherry&quot;</span></span>
<span class="line"><span>1378822154.117160 [0 127.0.0.1:56604] &quot;EXPIRE&quot; &quot;msg&quot; &quot;10086&quot;</span></span>
<span class="line"><span>1378822257.329412 [0 127.0.0.1:56604] &quot;KEYS&quot; &quot;*&quot;</span></span>
<span class="line"><span>1378822258.690131 [0 127.0.0.1:56604] &quot;DBSIZE&quot;</span></span></code></pre></div><h3 id="psync" tabindex="-1">PSYNC <a class="header-anchor" href="#psync" aria-label="Permalink to &quot;PSYNC&quot;">​</a></h3><p>用于复制功能(replication)的内部命令。</p><p>更多信息请参考 复制（Replication） 文档。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PSYNC &lt;MASTER_RUN_ID&gt; &lt;OFFSET&gt;</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>127.0.0.1:6379&gt; PSYNC ? -1</span></span>
<span class="line"><span>&quot;REDIS0006\\xfe\\x00\\x00\\x02kk\\x02vv\\x00\\x03msg\\x05hello\\xff\\xc3\\x96P\\x12h\\bK\\xef&quot;</span></span></code></pre></div><h3 id="save" tabindex="-1">SAVE <a class="header-anchor" href="#save" aria-label="Permalink to &quot;SAVE&quot;">​</a></h3><p>SAVE 命令执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。</p><p>一般来说，在生产环境很少执行 SAVE 操作，因为它会阻塞所有客户端，保存数据库的任务通常由 BGSAVE 命令异步地执行。然而，如果负责保存数据的后台子进程不幸出现问题时， SAVE 可以作为保存数据的最后手段来使用。</p><p>请参考文档： Redis 的持久化运作方式(英文) 以获取更多消息。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SAVE</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SAVE</span></span>
<span class="line"><span>OK</span></span></code></pre></div><h3 id="shutdown" tabindex="-1">SHUTDOWN <a class="header-anchor" href="#shutdown" aria-label="Permalink to &quot;SHUTDOWN&quot;">​</a></h3><p>SHUTDOWN 命令执行以下操作：</p><p>如果持久化被打开的话， SHUTDOWN 命令会保证服务器正常关闭而不丢失任何数据。</p><p>另一方面，假如只是单纯地执行 SAVE 命令，然后再执行 QUIT 命令，则没有这一保证 —— 因为在执行 SAVE 之后、执行 QUIT 之前的这段时间中间，其他客户端可能正在和服务器进行通讯，这时如果执行 QUIT 就会造成数据丢失。</p><p>SAVE 和 NOSAVE 修饰符</p><p>通过使用可选的修饰符，可以修改 SHUTDOWN 命令的表现。比如说：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SHUTDOWN</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; PING</span></span>
<span class="line"><span>PONG</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SHUTDOWN</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$ redis</span></span>
<span class="line"><span>Could not connect to Redis at: Connection refused</span></span>
<span class="line"><span>not connected&gt;</span></span></code></pre></div><h3 id="slaveof" tabindex="-1">SLAVEOF <a class="header-anchor" href="#slaveof" aria-label="Permalink to &quot;SLAVEOF&quot;">​</a></h3><p>通过执行 SLAVEOF host port 命令，可以将当前服务器转变为指定服务器的从属服务器(slave server)。</p><p>如果当前服务器已经是某个主服务器(master server)的从属服务器，那么执行 SLAVEOF host port 将使当前服务器停止对旧主服务器的同步，丢弃旧数据集，转而开始对新主服务器进行同步。</p><p>另外，对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。</p><p>利用『 SLAVEOF NO ONE 不会丢弃同步所得数据集』这个特性，可以在主服务器失败的时候，将从属服务器用作新的主服务器，从而实现无间断运行。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SLAVEOF 命令用于在 Redis 运行时动态地修改复制(replication)功能的行为。</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SLAVEOF 127.0.0.1 6379</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; SLAVEOF NO ONE</span></span>
<span class="line"><span>OK</span></span></code></pre></div><h3 id="slowlog" tabindex="-1">SLOWLOG <a class="header-anchor" href="#slowlog" aria-label="Permalink to &quot;SLOWLOG&quot;">​</a></h3><p>什么是 SLOWLOG</p><p>Slow log 是 Redis 用来记录查询执行时间的日志系统。</p><p>查询执行时间指的是不包括像客户端响应(talking)、发送回复等 IO 操作，而单单是执行一个查询命令所耗费的时间。</p><p>另外，slow log 保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启 slow log 而损害 Redis 的速度。</p><p>设置 SLOWLOG</p><p>Slow log 的行为由两个配置参数(configuration parameter)指定，可以通过改写 redis.conf 文件或者用 CONFIG GET 和 CONFIG SET 命令对它们动态地进行修改。</p><p>第一个选项是 slowlog-log-slower-than ，它决定要对执行时间大于多少微秒(microsecond，1秒 = 1,000,000 微秒)的查询进行记录。</p><p>比如执行以下命令将让 slow log 记录所有查询时间大于等于 100 微秒的查询：</p><p>CONFIG SET slowlog-log-slower-than 100</p><p>而以下命令记录所有查询时间大于 1000 微秒的查询：</p><p>CONFIG SET slowlog-log-slower-than 1000</p><p>另一个选项是 slowlog-max-len ，它决定 slow log 最多能保存多少条日志， slow log 本身是一个 FIFO 队列，当队列大小超过 slowlog-max-len 时，最旧的一条日志将被删除，而最新的一条日志加入到 slow log ，以此类推。</p><p>以下命令让 slow log 最多保存 1000 条日志：</p><p>CONFIG SET slowlog-max-len 1000</p><p>使用 CONFIG GET 命令可以查询两个选项的当前值：</p><p>查看 slow log</p><p>要查看 slow log ，可以使用 SLOWLOG GET 或者 SLOWLOG GET number 命令，前者打印所有 slow log ，最大长度取决于 slowlog-max-len 选项的值，而 SLOWLOG GET number 则只打印指定数量的日志。</p><p>最新的日志会最先被打印：</p><p>日志的唯一 id 只有在 Redis 服务器重启的时候才会重置，这样可以避免对日志的重复处理(比如你可能会想在每次发现新的慢查询时发邮件通知你)。</p><p>查看当前日志的数量</p><p>使用命令 SLOWLOG LEN 可以查看当前日志的数量。</p><p>请注意这个值和 slower-max-len 的区别，它们一个是当前日志的数量，一个是允许记录的最大日志的数量。</p><p>清空日志</p><p>使用命令 SLOWLOG RESET 可以清空 slow log 。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SLOWLOG subcommand [argument]</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; CONFIG GET slowlog-log-slower-than</span></span>
<span class="line"><span>1) &quot;slowlog-log-slower-than&quot;</span></span>
<span class="line"><span>2) &quot;1000&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>redis&gt; CONFIG GET slowlog-max-len</span></span>
<span class="line"><span>1) &quot;slowlog-max-len&quot;</span></span>
<span class="line"><span>2) &quot;1000&quot;</span></span></code></pre></div><h3 id="sync" tabindex="-1">SYNC <a class="header-anchor" href="#sync" aria-label="Permalink to &quot;SYNC&quot;">​</a></h3><p>用于复制功能(replication)的内部命令。</p><p>更多信息请参考 Redis 官网的 Replication 章节 。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SYNC</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; SYNC</span></span>
<span class="line"><span>&quot;REDIS0002\\xfe\\x00\\x00\\auser_id\\xc0\\x03\\x00\\anumbers\\xc2\\xf3\\xe0\\x01\\x00\\x00\\tdb_number\\xc0\\x00\\x00\\x04name\\x06huangz\\x00\\anew_key\\nhello_moto\\x00\\bgreeting\\nhello moto\\x00\\x05my_pc\\bthinkpad\\x00\\x04lock\\xc0\\x01\\x00\\nlock_times\\xc0\\x04\\xfe\\x01\\t\\x04info\\x19\\x02\\x04name\\b\\x00zhangyue\\x03age\\x02\\x0022\\xff\\t\\aooredis,\\x03\\x04name\\a\\x00ooredis\\aversion\\x03\\x001.0\\x06author\\x06\\x00huangz\\xff\\x00\\tdb_number\\xc0\\x01\\x00\\x05greet\\x0bhello world\\x02\\nmy_friends\\x02\\x05marry\\x04jack\\x00\\x04name\\x05value\\xfe\\x02\\x0c\\x01s\\x12\\x12\\x00\\x00\\x00\\r\\x00\\x00\\x00\\x02\\x00\\x00\\x01a\\x03\\xc0f&#39;\\xff\\xff&quot;</span></span>
<span class="line"><span>(1.90s)</span></span></code></pre></div><h3 id="time" tabindex="-1">TIME <a class="header-anchor" href="#time" aria-label="Permalink to &quot;TIME&quot;">​</a></h3><p>返回当前服务器时间。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>TIME</span></span></code></pre></div><p><strong>示例</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis&gt; TIME</span></span>
<span class="line"><span>1) &quot;1332395997&quot;</span></span>
<span class="line"><span>2) &quot;952581&quot;</span></span>
<span class="line"><span>redis&gt; TIME</span></span>
<span class="line"><span>1) &quot;1332395997&quot;</span></span>
<span class="line"><span>2) &quot;953148&quot;</span></span></code></pre></div>`,1335),i=[l];function t(c,o,d,r,u,g){return a(),n("div",null,i)}const k=s(e,[["render",t]]);export{b as __pageData,k as default};
